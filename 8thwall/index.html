<!DOCTYPE html>
  <html>
    <head>
<!-- Copyright (c) 2020 Headgear -->
<!-- head.html is optional; elements will be added to your html head before app.js is loaded. -->

<!-- Use "8thwall:" meta tags to hook into 8th Wall's build process and developer tools. -->
<meta name="8thwall:renderer" content="aframe">

<script src="./xrextras.js"></script> -->

<!-- tag for iOS icon homepage pinning -->
<link rel="apple-touch-icon" href="./assets/pagelogo.png">
 <link rel="icon" type="image/png" href="./assets/pagelogo.ico">
 
   <!-- meta tag for iOS video playback -->
   <meta name="apple-mobile-web-app-capable" content="yes">
   
   <!-- script for pushing debug logs onto screen! -->
   <script src="https://unpkg.com/aframe-log-component/dist/aframe-log-component.min.js"></script> 
   
   
   <style>

  #tapScreenButton {
    position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  right: 0;
  z-index:10;

}
  
  #uiContainer {
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  right: 0;
  z-index: 10;
  pointer-events: none;
}


#closeButton {
  position: absolute;
  width: 15vmin;
  height: 15vmin;
  background-color: white;
  bottom: 2vmax;
  border-radius: 7.5vmin;
  left: 50%;
  transform: translateX(-50%);
  background-size: 50%;
  background-repeat: no-repeat;
  background-position: center center;
  pointer-events: auto;
}


#closeButton {
  background-image: url('#');
  display: none;
}

   </style>
    </head>
    <body>
	<script>
// Copyright (c) 2020 Headgear
//
// app.js is the main entry point for your 8th Wall app. Code here will execute after head.html
// is loaded, and before body.html is loaded.
  
 // require('./xrextras.js');

//*****Global Variables START**********************************      
    
    //whether to show debug on screen or not - should be false for clients & staging & production!
    var debugOnVar = false //to use log with the command: AFRAME.log('test')

    //text strings
    var INFO_TEXT1 = "Tippen Sie auf den Bildschirm, um die Tür zu platzieren"  //initial text shown
    var INFO_TEXT2 = "Gehe durch das Tor, um das Erlebnis zu starten." //text shown after placement
    var INFO_TEXT3 = "Einen Schritt zurück und es geht weiter, order tippen Sie zum Zurücksetzen auf den Bildschirm" //text shown when walking out of balcony
    var sceneLocationTextString = "Scene Location" //text to be shown above the door
    
    
    //experience setup ** THESE CAN BE CHANGED
    var hideDoorOnWalkthrough = true //true means door is hidden when user walks through - Needed for 2nd app demo!!
    var showBalcony = true   //true means balcony is shown
    var videoElsePhoto = true //true means video not photo
    var sceneLocationText = false //true means text will be shown above the door signifying the location
    var doorTriggerDistance = 7.5  //camera starts around a value of 9. Where a value of 0 = at the door
    var containsDoorAnimation = false //whether door animation exists

    //global logic vars ** DO NOT CHANGE THESE
    var isInPortalSpace = false
    var wasOutside = true
    var withinPortalBounds = false
    var doorOpened = false
    var resetSceneTriggered = false //called for proper reset of the hide door when walking through scenerio
    var outofBounds = false
    var doorVisible = false
    var materialOriginalDoor = new THREE.MeshStandardMaterial({})
    var materialOriginalBalcony = new THREE.MeshStandardMaterial({})

//*****Global Variables END************************************




 //This component plays the video on screen tap if it doesn't autoplay and resets the tracking on screentap
    AFRAME.registerComponent('tap-handler', {
      init: function() {
           
            const uiContainer = document.getElementById('uiContainer')
            const closeButton = document.getElementById('placeholderButton')
            const tapScreen = document.getElementById('tapScreenButton')

            // Container starts hidden so it isn't visible when the page is still loading
            
            //uiContainer.addEventListener('click', () => {
            //  console.log('container pressed')
            //})
        
            //tap screen listener for non-specific components:
            tapScreen.addEventListener('click', () => {
                  console.log('tapScreen pressed')
                  
                  // recenter scene
                  let scene = this.el.sceneEl
                  scene.emit('recenter')
                  
                
                  //to reset the door visibility if previously hidden on walkthrough
                  if (hideDoorOnWalkthrough) {
                      resetSceneTriggered = true
                   }
                  //reset vars
                  outofBounds = false
                  
                  //reset narrative audio
                  var soundEntity = document.querySelector('#soundcue')
                  soundEntity.components.sound.stopSound();
                  
                  //check if video is playing yet
                  if (videoElsePhoto){
                    //play video
                    var video = document.querySelector('#videosphere').components.material.material.map.image;
                    if (!video) { return; }
                    video.play();
                   }
            })  //end tap screen eventhandler
   
      }
    });

    //This handles starting the show door animation on a screen tap
    AFRAME.registerComponent('show-door-ani-on-tap', {
      init: function() {
         const tapScreen = document.getElementById('tapScreenButton')
         //tap screen listener:
            tapScreen.addEventListener('click', () => {
                   
                  //Door & Balcony: material change
                  if (!doorVisible || (doorVisible)){ //need to fix this second condition
                    
                        //set wirefirame materials door:
                          let el = document.getElementById('doorEntity');
                          let mesh = el.getObject3D('mesh'); 
                          if (!mesh){return;}
                          //console.log(mesh);
                          mesh.traverse(function(node){
                             if (node.isMesh){  
                               let materialOriginal = node.material
                               node.material = new THREE.MeshStandardMaterial({
                                  color : 0x00ff00,
                                 wireframe : true,
                                 emissive:  0x00ff00,
                                 emissiveIntensity: 10,
                                 opacity : 1
                               });
                             }
                          });
                          //set wireframe materials balcony:
                          if (showBalcony) {
                              let el = document.getElementById('balcony');
                                let mesh = el.getObject3D('mesh'); 
                                if (!mesh){return;}
                                //console.log(mesh);
                                mesh.traverse(function(node){
                                   if (node.isMesh){  
                                     let materialOriginal = node.material
                                     node.material = new THREE.MeshStandardMaterial({
                                        color : 0x00ff00,
                                       wireframe : true,
                                       emissive:  0x00ff00,
                                       emissiveIntensity: 10,
                                       opacity : 1
                                     });
                                   }
                                });        
                          }
                  
                        //hide info text and arrow while door is animating
                        document.getElementById('infoText').object3D.visible = false
                        document.getElementById('arrow-image-holder').setAttribute('visible', 'false')
                        //start animation of box hider
                        document.getElementById('boxInFrontOfDoor').emit('showportal')
                        document.getElementById('boxInFrontOfDoor').setAttribute('visible', 'true')
                        document.getElementById('doorEntity').setAttribute('visible', 'true')
                        if (showBalcony) { document.getElementById('balcony').setAttribute('visible', 'true') }
                    
                  }
            })
      }
    });


    //This handles the logic for when the show door animation is complete
    AFRAME.registerComponent('show-door-ani-over-logic', {
      init: function() {
      
          document.getElementById('boxInFrontOfDoor').addEventListener('animationcomplete', (e) => {
          console.log(e.detail.name);
                                    
          if (e.detail.name == 'animation__showportal') {
                 console.log('show portal done')
                 document.getElementById('boxInFrontOfDoor').setAttribute('visible', 'false')
                 
                  let eldoor = document.getElementById('doorEntity');
                  let mesh = eldoor.getObject3D('mesh'); 
                  if (!mesh){return;}
                  mesh.traverse(function(node){
                    if (node.isMesh){  
                      node.material = materialOriginalDoor
                    }
                  });
            if (showBalcony) {
                  let elbalcony = document.getElementById('balcony');
                  let mesh = elbalcony.getObject3D('mesh'); 
                  if (!mesh){return;}
                  mesh.traverse(function(node){
                     if (node.isMesh){  
                       node.material = materialOriginalBalcony
                     }
                  });
                }
            doorVisible = true
            
            //change text / reshow
            document.getElementById('infoText').setAttribute('text', 'value: ' + INFO_TEXT2)
            document.getElementById('infoText').object3D.visible = true
            //show arrow
            document.getElementById('arrow-image-holder').setAttribute('visible', 'true')
                 
          }
        }) 
      }
    })

 
      //This hides video/photo sphere inside the initial hider box in case user walks in their before spawning door
    AFRAME.registerComponent('hide-after-load', {         
          init: function () {
             // After entity has loaded scale down to make 'invisible'
            this.el.addEventListener('loaded', (e) => {

                this.el.object3D.visible = false;
            })
          }
     })
 
    //This shows video/photo sphere on tap
    AFRAME.registerComponent('show-on-tap', {         
          init: function () {
            const tapScreen = document.getElementById('tapScreenButton')
            //tap screen listener:
            tapScreen.addEventListener('click', () => {
                if (this.el == document.getElementById('videosphere')) { if (videoElsePhoto) {if (!this.el.object3D.visible) {this.el.object3D.visible = true;}}}
                else if (this.el == document.getElementById('photosphere')) { if (!videoElsePhoto) {if (!this.el.object3D.visible) {this.el.object3D.visible = true;}}}
            })
          }
     })

    //This shows models on tap
    AFRAME.registerComponent('scaleup-on-tap', {         
          init: function () {
            const tapScreen = document.getElementById('tapScreenButton')
            //tap screen listener:
            tapScreen.addEventListener('click', () => {
                this.el.object3D.scale.set(2.3, 2.3, 2.3);
            })
          }
     })  
     

    //This saves the original material of the door and balcony models
    AFRAME.registerComponent('save-orginal-model-material', {         
          init: function () {
             // After gltf model has loaded,save it's default material
            let eldoor = document.getElementById('doorEntity');
            eldoor.addEventListener('model-loaded', function(ev){
              let mesh = eldoor.getObject3D('mesh'); 
              if (!mesh){return;}
              mesh.traverse(function(node){
                 if (node.isMesh){  
                   materialOriginalDoor = node.material
                   
                 }
              });
            });
            if (showBalcony) {
                elbalcony = document.getElementById('balcony');
                elbalcony.addEventListener('model-loaded', function(ev){
                  let mesh = elbalcony.getObject3D('mesh'); 
                  if (!mesh){return;}
                  mesh.traverse(function(node){
                     if (node.isMesh){  
                       materialOriginalBalcony = node.material
                       
                     }
                  });
                });
            }
          }
        });


        

      // This component gives the invisible hider walls the property they need
      AFRAME.registerComponent('hider-material', {
        init: function() {
          const mesh = this.el.getObject3D('mesh')
          mesh.material.colorWrite = false
        },
      })

      // To set the initial info text
      AFRAME.registerComponent('set-initial-info-text', {
        init: function() {
          this.el.setAttribute('text', 'value: ' + INFO_TEXT1)
        },
      })
      
      
      // This component hides and shows certain elements as the camera moves as well as info text and balcony
      AFRAME.registerComponent('portal', {
        schema: {
          width: {default: 6},
          height: {default: 30}, //To do: make this dynamic
          depth: {default: 1}, //TO DO: check this value
        },
        init: function(){

          this.camera = document.getElementById('camera')
          this.contents = document.getElementById('portal-contents')
          this.walls = document.getElementById('hider-walls')
          this.portalWall = document.getElementById('portal-return-opening')
          this.portalWorld = document.getElementById('portal-world')
          
          //get sceneHolder distance
          this.sceneholder = document.getElementById('scene-holder')
          depthOffset = this.sceneholder.getAttribute('position').z
          

          //hide or show balcony depending on global var - now set in tap-handler
          //document.getElementById('balcony').object3D.visible = showBalcony
          
          
          //XR8.XrController.configure({disableWorldTracking: false})
            

        },
        tick: function() {
          const position = this.camera.object3D.position

          var isOutside = position.z  > ((this.data.depth / 2) + depthOffset)
          const withinPortalBounds = position.y < this.data.height && Math.abs(position.x) < this.data.width / 2
          //console.log('camera.z = ' + position.z + 'compared to: '+ (this.data.depth / 2) + depthOffset)
          
          //check if reset scene has been triggered
          if (resetSceneTriggered) {
               isInPortalSpace = false
               isOutside = true
               resetSceneTriggered = false
               if (hideDoorOnWalkthrough) {
                  //through door show  door
                  document.getElementById('doorEntity').setAttribute('visible', 'true')
                  document.getElementById('balcony').setAttribute('visible', 'true')
              }
          }
          // check if user has walked out of balcony
          if (isInPortalSpace && !isOutside && !hideDoorOnWalkthrough) {
     
                withinBalconyWidth = position.y < this.data.height && Math.abs(position.x) < this.data.width // 2
                withinBalconyDepth = position.z  > (-(this.data.depth * 4) + depthOffset)

                //AFRAME.log('withinBalconyWidth = ' + withinBalconyWidth + ", withinBalconyDepth = " + withinBalconyWidth);
                if (!withinBalconyWidth && !withinBalconyDepth && !outofBounds) {
                    AFRAME.log('out of balcony');
                    outofBounds = true
                    //change text / reshow
                    document.getElementById('infoText').setAttribute('text', 'value: ' + INFO_TEXT3)
                    document.getElementById('infoText').object3D.visible = true
                } else if (withinBalconyWidth && withinBalconyDepth && outofBounds) {
                    AFRAME.log('in balcony again');
                    outofBounds = false
                    //hide out of bounds text
                    document.getElementById('infoText').object3D.visible = false
                } else if (outofBounds) {
                    AFRAME.log('position.z = ' + position.z + ", Depth = " + (-(this.data.depth * 4) + depthOffset)); //(((-1 * this.data.depth) / 2) - depthOffset));
                }

          }
          // check if user has walked into portal
          if (!isInPortalSpace && !isOutside && withinPortalBounds && doorVisible) {
                isInPortalSpace = true
              //hide stuff:
                //through door hide info text
                document.getElementById('infoText').object3D.visible = false
                //through door hide arrow
                document.getElementById('arrow-image-holder').setAttribute('visible', 'false')
                
              if (hideDoorOnWalkthrough) {
                //through door hide door
                document.getElementById('doorEntity').setAttribute('visible', 'false')
                document.getElementById('balcony').setAttribute('visible', 'false')
              }
              
              //play narrative sound
              var entity = document.querySelector('#soundcue')
              entity.components.sound.playSound();
              
              //test to disable world tracking
              //XR8.stop()
              //XR8.XrController.configure({disableWorldTracking: false})
          
            //else check if user has walked out of portal
          } else if (isInPortalSpace && isOutside && !hideDoorOnWalkthrough) {
              isInPortalSpace = false
              //reset narrative audio
              document.querySelector('#soundcue').components.sound.stopSound()
          }
          
          //door animation check
          if ((position.z < doorTriggerDistance) && !doorOpened && containsDoorAnimation) {
              doorOpened = true
              //console.log('door opened')
          } else if ((position.z > doorTriggerDistance) && doorOpened && containsDoorAnimation) {
              doorOpened = false
              //console.log('door closed')
          }
          //end door animation check
          //console.log('isInPortalSpace = ' + isInPortalSpace + ', isOutside = ' + isOutside)
          //set visibilities of portal components
          this.contents.object3D.visible = isInPortalSpace || isOutside
          this.walls.object3D.visible = !isInPortalSpace && isOutside
          this.portalWall.object3D.visible = isInPortalSpace && !isOutside && !hideDoorOnWalkthrough
          this.portalWorld.object3D.visible = isInPortalSpace

          wasOutside = isOutside
          
          
        }
      })
    
    
      //To hide or show  the sceneLocationText above door
      AFRAME.registerComponent('scenelocation_textholder_controller', {
        init: function() {
          
          if (sceneLocationText) {
            document.getElementById('sceneLocationTextHolder').setAttribute('visible', 'true')
          } else {
            document.getElementById('sceneLocationTextHolder').setAttribute('visible', 'false')
          }
        },
         
      });
      
      //to set the text of the scenelocationText entitys
        AFRAME.registerComponent('scenelocation_text_setter', {
        init: function() {
            if (sceneLocationText) {
            this.el.setAttribute('text', 'align: center; value: ' + sceneLocationTextString + '; color: white; font: https://cdn.aframe.io/fonts/mozillavr.fnt;')
          }
        },
         
      })
    
    //to show either photo or video sphere
     AFRAME.registerComponent('photo-or-video', {
        init: function() {
          if (videoElsePhoto) {
            document.querySelector("#photosphere").setAttribute('visible', 'false')

          } else {
            document.querySelector("#videosphere").setAttribute('visible', 'false')
          }
          
        },
      })
    
 
    
              
    
   

    
 // To handle the looping arrow-animation
      AFRAME.registerComponent('arrow-ani-setup', {
        init: function() {
          var arrow1 = document.querySelector('#arrow1')
          //var arrow2 = document.querySelector('#arrow2')
          //var arrow3 = document.querySelector('#arrow3')
          this.el.addEventListener('loaded', (e) => {
              //console.log('loaded')
              arrow1.emit('moveup');
              //setTimeout(function(){ arrow2.emit('moveup'); }, 400);
              //setTimeout(function(){ arrow3.emit('moveup'); }, 800);
          })
        },
      })
       
       AFRAME.registerComponent('arrow-ani', {
        init: function() {
          this.el.addEventListener('animationcomplete', (e) => {
            //console.log(e.detail.name);
            if (e.detail.name == 'animation__moveup') {
                this.el.emit('moveup');
                this.el.emit('fadein');
            } 
            if (e.detail.name == 'animation__fadein') {
                  //console.log('fadein done')
                    this.el.emit('fadeout');
                } 
            if (e.detail.name == 'animation__fadeout') {
                  //console.log('fadeout done')
                    this.el.emit('fadein');
                }
          })

      
        },
      })



      // For showing debug logs on screen
      AFRAME.registerComponent('debugon', {
        init: function() {
          this.el.setAttribute('visible', debugOnVar)
        },
      })
      

    //Dynamic Lighting - partially used
      AFRAME.registerComponent('xr-light', {
        schema: {
          min: {default: 0},
          max: {default: 20}
        },
        init: function() {
          const startListen = () => {
            window.XR.XrController.configure({enableLighting: true})
            window.XR.addCameraPipelineModule({
              name: 'xr-light',
              onUpdate: ({processCpuResult}) => {
                if (processCpuResult.reality && processCpuResult.reality.lighting && processCpuResult.reality.lighting.exposure) {
                  this.intensity = 1 + processCpuResult.reality.lighting.exposure
                }
              }
            })
          }

          this.intensity = 1

          window.XR ? startListen() : window.addEventListener('xrloaded', startListen)

          },
        tick: function() {
          let headlights = this.el.sceneEl.querySelectorAll('a-cone')
          var tempIntensity = Math.max(this.data.min, Math.min((this.system.intensity * 10), this.data.max))
          this.el.setAttribute('light', 'intensity: ' + tempIntensity)
          //console.log(tempIntensity)
         
                    
          }
        })




  //Video event handler not used yet
    AFRAME.registerComponent('videoeventhandler', {
      init: function() {
          if (videoElsePhoto){
            var video = this.el.components.material.material.map.image;
           
           
             //video event testing
                  video.addEventListener('waiting', (event) => {
              console.log('Video is waiting for more data.');
            });
            
                  video.addEventListener('stalled', (event) => {
              console.log('Video is stalled for more data.');
            });
            
            video.addEventListener('playing', (event) => {
              console.log('Video is no longer paused');
            });
            
            video.addEventListener('canplay', (event) => {
              console.log('Video can start, but not sure it will play through.' + video.readyState);
            });
            video.addEventListener('progress', (event) => {
             // console.log('resource loading buffered = ' + video.buffered);
            });
            video.addEventListener('canplaythrough', (event) => {
              console.log('I think I can play through the entire ' + 'video without ever having to stop to buffer.');
            });
            video.addEventListener('loadeddata', (event) => {
              console.log('Yay! The readyState just increased to  ' + 'HAVE_CURRENT_DATA or greater for the first time.');
            });
          }
      },
       
    });




//shadow test no used
    AFRAME.registerComponent('shadow-material', {
  init:function() {
    this.material = new THREE.ShadowMaterial()
    this.el.getOrCreateObject3D('mesh').material = this.material
    this.material.opacity = 0.4
  }
})



//test componenent function - currently not working or used
      AFRAME.registerComponent('portal-size', {
      init: function() {
          console.log('portal size called. This:')
          console.log(this)
          console.log('portal size called. object3d:')
          console.log(this.el.Object3D)
          
          //get size vector
          var model = this.el.object3D;
          var box = new THREE.Box3().setFromObject( model );
          const sizeVector = new THREE.Vector3();
          var size = box.getSize( sizeVector );
          var loader = new THREE.OBJLoader(model);
             var helper = new THREE.BoxHelper(loader, 0xff0000);
          helper.update();
          // If you want a visible bounding box
          scene.add(helper);
          // If you just want the numbers
                    console.log('1portal size called. size:')
          console.log(helper.box.min);
          console.log(helper.box.max);
          
          helper = new THREE.BoxHelper(model, 0xff0000);
          helper.update();
          // If you want a visible bounding box
          scene.add(helper);
          // If you just want the numbers
                    console.log('2portal size called. size:')
          console.log(helper.box.min);
          console.log(helper.box.max);
          
          
          
          

        //  console.log(size.x)
        // console.log(size.y)
        // console.log(size.z)
          //update scale:
          // With three.js
          //el.object3D.scale.set(1, 2, 3);
        },
      })
      
 
 
	</script>
	<!-- Copyright (c) 2020 Headgear -->

<!-- body.html ; elements will be added to your html body after app.js is loaded. -->

 <!-- These HTML elements are used to show an UI laid over the scene -->
      <div id="tapScreenButton"></div>
      <div id="uiContainer" style="display: none">
        <div id="placeholderButton"></div>
      </div>

<!-- aframe scene components -->

 <a-scene id="scene"
 light="defaultLightsEnabled: false"
      xrweb
      portal
      tap-handler
      aframe-log-component
      photo-or-video
      xrextras-almost-there
      xrextras-loading
      xrextras-runtime-error>

      <!-- We can define assets here to be loaded when A-Frame initializes -->
      <a-assets>
       
       <!-- <a-asset-item id="doorModel" src="./assets/door230cm.glb"></a-asset-item>  -->
        <a-asset-item id="doorModel" src="./assets/door_model.glb"></a-asset-item>
        <a-asset-item id="balconyModel" src="./assets/balcony_model.glb"></a-asset-item>
        
        <img id="arrowhead-image" src="./assets/arrowhead.png">
        
          <!-- asset for 360 photo and or video poster -->
        <img id="photo" src="./assets/video_thumbnail.jpg">

         <!-- asset for narrator -->
        <audio id="audio" src="./assets/narrative.mp3" preload="auto"></audio>
        
      </a-assets>
      <!-- Different timeout mentioned here in case we wish to start the video streaming sooner -->
      <a-assets timeout="3000">
        
        <video id="video1" src="./assets/360_video.mp4"
          loop crossorigin="anonymous" preload="auto" playsinline webkit-playsinline></video>
      
      </a-assets>

       <a-camera
        id="camera"
        position="0 11.5 9.2"> <!-- changing the depth/height (y) and distance (z) of the camera results in a rescale of the door -->
           
          <a-entity id="arrow-image-holder" visible="false" arrow-ani-setup>
             <a-image id="arrow1" position="0 0.025 -1" scale="0.1 0.2 0.1" src="#arrowhead-image" transparent="true" shader="flat" opacity="0.0"
                          animation__moveup="property: position; from: 0 0.025 -1; to: 0 0.4 -1.5; dur: 2000; startEvents: moveup; easing: easeInOutQuad "
                          animation__fadein="property: material.opacity; from: 0.0; to: 1.0; startEvents: animtioncomplete__moveup; dur: 1000; startEvents: fadein; easing: easeInOutQuad"
                           animation__fadeout="property: material.opacity; from: 1.0; to: 0.0; dur: 1000; startEvents: animationcomplete__fadein; startEvents: fadeout; easing: easeInOutQuad "
                          
                           arrow-ani>
              </a-image>  
              <!-- for multiple arrows:
              <a-image id="arrow2" position="0 0.025 -1" scale="0.1 0.1 0.1" src="#arrowhead-image" transparent="true" shader="flat" opacity="0.0"
                          animation__moveup="property: position; from: 0 0.025 -1; to: 0 0.4 -1; dur: 2000; startEvents: moveup; easing: easeInOutQuad"
                          animation__fadein="property: material.opacity; from: 0.0; to: 1.0; startEvents: animtioncomplete__moveup; dur: 1000; startEvents: fadein; easing: easeInOutQuad"
                           animation__fadeout="property: material.opacity; from: 1.0; to: 0.0; dur: 1000; startEvents: animationcomplete__fadein; startEvents: fadeout; easing: easeInOutQuad"
                          
                           arrow-ani>
              </a-image>  
              <a-image id="arrow3" position="0 0.025 -1" scale="0.1 0.1 0.1" src="#arrowhead-image" transparent="true" shader="flat" opacity="0.0"
                          animation__moveup="property: position; from: 0 0.025 -1; to: 0 0.4 -1; dur: 2000; startEvents: moveup; easing: easeInOutQuad "
                          animation__fadein="property: material.opacity; from: 0.0; to: 1.0; startEvents: animtioncomplete__moveup; dur: 1000; startEvents: fadein; easing: easeInOutQuad"
                           animation__fadeout="property: material.opacity; from: 1.0; to: 0.0; dur: 1000; startEvents: animationcomplete__fadein; startEvents: fadeout; easing: easeInOutQuad "
                          
                           arrow-ani>
              </a-image >  
              -->
          </a-entity> 
        
              <a-entity
            id="infoText"
            text="align: center; value: Tor platzieren; color: white; wrapCount: 22; shader: msdf; negate: false; font: ./assets/msyaheide-19hs69cri5.glb;" 
            position="0 -0.1 -1"
            scale="0.5 0.5 0.5"
            set-initial-info-text>
          </a-entity>
              
           <!-- Logging to screen -->
           <a-log position="1 2.5 -4" visibile="false" debugon></a-log>
            
      </a-camera>

      <!-- light -->
      <a-entity
        light="type: directional;
               intensity: 0;
               target: #doorEntity;"
        position="1 4.3 2.5">
      </a-entity>
      <a-light type="ambient" intensity="0"></a-light>

      <!-- main scene holder - used to push door further back on spawn. NOTE: changing Z results in having to move the camera Y up or down -->
      <a-entity id="scene-holder" position="0 0 -10">
        
            <!-- box in front of door for ani in: wScale effected by width of door. yPosition & ySacle (set also in ani) effected by height of door 
            was: 
            scale="20 76 15"
            position="0 38 0"
            animation__showportal="property: scale; from: 20 76 15; to: 20 0 15; dur: 1900; startEvents: showportal; easing: linear "
            -->
              <a-box id="boxInFrontOfDoor"
                scale="20 76 15"
                position="0 38 0"
                animation__showportal="property: scale; from: 20 76 15; to: 20 38 15; dur: 1900; startEvents: showportal; easing: linear "
                hider-material
                show-door-ani-over-logic></a-box>
        
            <!-- Doorway door model (note: order is important as first listed is always drawn on top) -->
            <a-entity
                id="doorEntity"
                position="0 0 0"
                scale="0 0 0"
                gltf-model="#doorModel"
                visible="true"
                animation__scaleup="property: scale; from: 2.3 0 2.3; to: 2.3 2.3 2.3; dur: 2000; startEvents: scaleup; easing: easeOutQuad "
                save-orginal-model-material
                show-door-ani-on-tap
                scaleup-on-tap>
                  
                  <!-- text sign --> 
                  <!-- standard font: 
                  font: https://cdn.aframe.io/fonts/mozillavr.fnt;" 
                  -->
                  <!-- custom font: 
                  shader: msdf; font:https://raw.githubusercontent.com/etiennepinchon/aframe-fonts/master/fonts/play/Play-Regular.json;"
                  from: https://github.com/etiennepinchon/aframe-fonts -->
                <a-entity id="sceneLocationTextHolder" scenelocation_textholder_controller>
                    <a-entity
                        id="sceneLocationTextEntity"
                        text="align: center; value: Location; color: white; font: https://cdn.aframe.io/fonts/mozillavr.fnt;" 
                        position="0 8 1.45"
                        scale="12 12 12"
                        scenelocation_text_setter
                        >
                    </a-entity>
                    <!-- text shadow attempt -->
                    <a-entity
                        id="sceneLocationTextShadowEntity"
                        text="align: center; value: Location; color: black; font: https://cdn.aframe.io/fonts/mozillavr.fnt;" 
                        position="0 8 1.4"
                        scale="12.1 12.1 12.1"
                        scenelocation_text_setter
                        >
                    </a-entity>
                </a-entity>
            </a-entity>
            
      
            <!-- Hider walls -->
            <a-entity id="hider-walls">
              <!-- above portal on front: wScale effected by width of door. yPosition & ySacle (set also in ani) effected by height of door  -->
              <a-box id="abovePortalHiderWall"
                scale="10 100 1"
                position="0 67 0"
                animation__scaleup="property: scale; from: 10 135 1; to: 10 100 1; dur: 2000; startEvents: scaleup; easing: easeOutQuad "
                hider-material></a-box>
              <!-- front left: wScale effected by width of door-->
              <a-box
                scale="92 100 1"
                position="-50 50 0"
                hider-material></a-box>
              <!-- front right: wScale effected by width of door-->
              <a-box
                scale="92 100 1"
                position="50 50 0"
                hider-material></a-box>
              <!-- back -->
              <a-box
                scale="200 100 1"
                position="0 50 200"
                hider-material></a-box>
              <!-- floor left -->
              <a-box
                scale="200 1 201"
                position="0 100 100"
                hider-material></a-box>
              <!-- floor right -->
              <a-box
                scale="200 1 199"
                position="0 -0.5 100"
                hider-material></a-box>
              <!-- side left -->
              <a-box
                scale="1 100 205"
                position="-100 50 100"
                hider-material></a-box>
              <!-- side right -->
              <a-box
                scale="1 100 205"
                position="100 50 100"
                hider-material></a-box>
            </a-entity>
            
            <!-- return side: xScale effected by width of door. yScale and yHeight effected by door height -->
            <a-entity id="portal-return-opening">
              <a-plane
                scale="7 17 1"
                rotation="180 0 0"
                position="0 8.5 0.5"
                hider-material></a-plane>
            </a-entity>
      
            <a-entity id="portal-contents"  >
              
              <!-- Balcony  -->
                <a-entity id="balcony"
                position="0 0 0"
                gltf-model="#balconyModel"
                scale="0 0 0"
                visible="true"
                animation__scaleup="property: scale; from: 2.3 0 2.3; to: 2.3 2.3 2.3; dur: 2000; startEvents: scaleup; easing: easeOutQuad "
                save-orginal-model-material
                show-door-ani-on-tap
                scaleup-on-tap></a-entity>
                
             
           <a-videosphere id="videosphere" rotation="0 90 0" src="#video1"  videoeventhandler hide-after-load show-on-tap>
           </a-videosphere>    
      
            <!-- sky background for 360 photo -->
            <a-sky id="photosphere" src="#photo" photo-or-video hide-after-load show-on-tap></a-sky>
            
            <!-- ground outside if separate should go here --> 
              
            </a-entity>
        
            <!-- ground inside portal --> 
       
            <a-entity id="portal-world">
             
            </a-entity>
            
   
            
            <!-- narrator audio track -->
            <a-entity id="soundcue" sound="src: #audio; autoplay: false;"></a-entity>
            
     </a-entity>
    
    </a-scene>
    
   

  

  
  </html>