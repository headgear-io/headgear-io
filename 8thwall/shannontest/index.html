
<!DOCTYPE html>
  <html>
    <head>
      <!-- d16b784dcf125bafd1967e30c1918f909ea6c5c7 8d2927fdfbae9ea66e34caa4039a4c3f -->
      <meta charset="UTF-8">
  
      <title>Shannon test</title>
      <meta itemprop="name" content="Shannon test">
      <meta name="twitter:title" content="Shannon test">
      <meta name="og:title" content="Shannon test">
      <meta name="og:site_name" content="Shannon test">
     <meta name="image" content="//cdn.8thwall.com/apps/cover/2tlzr9duznmbo065d5o12dravytoyoffz3ylwdcah3cs0z1n2hwykr3o-preview">
      <meta itemprop="image" content="//cdn.8thwall.com/apps/cover/2tlzr9duznmbo065d5o12dravytoyoffz3ylwdcah3cs0z1n2hwykr3o-preview">
      <meta name="og:image" content="//cdn.8thwall.com/apps/cover/2tlzr9duznmbo065d5o12dravytoyoffz3ylwdcah3cs0z1n2hwykr3o-preview">
      <meta name="twitter:image:src" content="//cdn.8thwall.com/apps/cover/2tlzr9duznmbo065d5o12dravytoyoffz3ylwdcah3cs0z1n2hwykr3o-preview">
    
      <meta name="og:type" content="website">
      <meta name="twitter:card" content="summary">
		
		<script type="text/javascript">
		var trackingProvider = "Tealium";
		switch (trackingProvider) {
			case "Tealium":
				var utag_data = {
					page_name : "Shannon test",
					page_section_path : "",
					page_section_1 : "",
					page_section_2 : "",
					page_platform : "" ,
					app_name : ""
				};
				(function(a,b,c,d){
					a='https://tags.tiqcdn.com/utag/axelspringer/welt/prod/utag.js';
					b=document;c='script';d=b.createElement(c);d.src=a;d.type='text/java'+c;d.async=true;
					a=b.getElementsByTagName(c)[0];a.parentNode.insertBefore(d,a);
				})();
				break;
		}
		</script>
		
      <script async src="https://apps.8thwall.com/xrweb?appKey=9ubVGhOgJPn7QLVszXJIWUa719wbe3cIpAX47uq4tgZ8h2SCeV2dGq5gafrHWBOGwsa7i3&s=1"></script>
     <script src="https://cdn.8thwall.com/web/aframe/8frame-0.9.2.min.js"></script>
      <script src="xrextras_13.2.js"></script>

      <!-- Copyright (c) 2020 Headgear GmbH -->

   <!-- meta tag for iOS video playback -->
   <meta name="apple-mobile-web-app-capable" content="yes">
   
   
   <script src="https://demos.jquerymobile.com/1.3.2/js/jquery.js"></script>
   <!-- currently not working: <script src="https://demos.jquerymobile.com/1.3.2/js/jquery.mobile-1.3.2.min.js"></script> -->
       
	   <style>

@font-face {
	font-family: 'MarkOT';
	src: url('./assets/MarkOT-zthr8k5crh.glb') format('truetype');
	
}
.prompt-box-8w * {
    font-family: 'MarkOT' !important;
}
.prompt-button-8w {
  
}
.button-primary-8w {


  background-color: #00507F !important;
}

#infoText {
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  right: 0;
  height: 200px;
  text-align: center;
  margin: auto;
  padding-top: 150px;
  width: 250px;
  font-size: 24px;
  color: black;
  -webkit-text-fill-color: white; /* Will override color (regardless of order) */
  -webkit-text-stroke-width: 1px;
  -webkit-text-stroke-color: black;
  z-index:11;
   font-family: 'MarkOT';
}

#internetText {
  position: absolute;
  left: 0;
  top: 0;
  bottom: -50%;
  right: 0;
  height: 200px;
  text-align: center;
  margin: auto;
  padding-top: 150px;
  width: 250px;
  font-size: 16px;
  color: black;
  -webkit-text-fill-color: white; /* Will override color (regardless of order) */
  -webkit-text-stroke-width: 0.5px;
  -webkit-text-stroke-color: black;
  z-index:11;
   font-family: 'MarkOT';
}

#outofboundsBackground{
    
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  right: 0;
  height:100%;
  z-index:10;
}
#tapScreenButton{
    
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  right: 0;
  height:100%;
  z-index:20;
}
#uiContainer{
    position: fixed;
    width:100%;
    height: 31vmin;
	bottom: -16vmin;
	z-index: 30;
	transition: all .3s ease-out;
	float:left;
	padding:0;
	margin:0;
	display: none;
}
#carrotContainer {
	width: 100%;
	height: 15vmin;
	position: relative;
	display: flex;
	align-items: center;
	justify-content: center;
	font-size: 15vmin;
	font-weight: bolder;
	color: white;
	opacity: 0.9;
	-webkit-text-stroke: 1.5px black;
	transition: all .3s ease-out;
	transform: rotate(0deg);
}
#shareButtonContainer {
  position: relative;
  width: 33%;
  float:left;
  padding:0;
  margin:0;
}
#shareButton {
 position: relative;
  width: 15vmin;
  height: 15vmin;
  background-color: #00507F;
  border-radius: 7.5vmin;
  transform: translateX(-50%);
  left: 50%;
  display: flex;
  align-items: center;
  justify-content: center;

  background-size: 50%;
  background-repeat: no-repeat;
  background-position: center center;
  pointer-events: auto;
  background-image: url('./assets/share_icon_white-dtpa4k5ir6.png');
  
}

#audioButtonContainer {
  position: relative;
  width: 33%;
  float:left;
  padding:0;
  margin:0;
  }
 #audioButton { 
 position: relative;
  width: 15vmin;
  height: 15vmin;
  background-color: #00507F;
  border-radius: 7.5vmin;
  transform: translateX(-50%);
  left: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  background-size: 50%;
  background-repeat: no-repeat;
  background-position: center center;
  pointer-events: auto;
  background-image: url('./assets/speaking_icon_white-yhdqgbt9rh.png');
  
}

#infoButtonContainer {
  position: relative;
  width: 33%;
  float:left;
  padding:0;
  margin:0;
  }
 #infoButton {
 position: relative;
  width: 15vmin;
  height: 15vmin;
  background-color: #00507F;
  border-radius: 7.5vmin;
  background-size: 50%;
  background-repeat: no-repeat;
  background-position: center center;
  pointer-events: auto;
  background-image: url('./assets/info_icon_white-c9i9c69di6.png');
  transform: translateX(-50%);
  left: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
}

.ui-loader {
	display:none !important;
}
   </style>
      
</head>
<body>
	<script>
// Copyright (c) 2020 Headgear

  
  
// iOS motion sensors text override and video preload workaround
var in_dom = false;
var observer = new MutationObserver(function(mutations) {
    if (document.querySelector('.prompt-box-8w')) {
        if (!in_dom) {
            document.querySelector('.prompt-box-8w p').innerHTML = "<strong>Aktivieren Sie den Zugriff auf die Bewegungssensoren</strong>";
            document.querySelector('.prompt-button-8w').innerHTML = "Abbrechen";
            document.querySelector('.button-primary-8w').innerHTML = "Fortsetzen";
        }
        in_dom = true;
        
        $(".button-primary-8w").on("click", function() {
               if (videoElsePhoto){
                       //stop video
                       var videoPlayer = document.querySelector('#videosphere').components.material.material.map.image;
                       if (videoPlayer) { 
                            videoPlayer.play();
                            videoPlayer.pause();
                            console.log('video workaround')
                       } else { console.log('no video found') }
                    }
        });
    } else if (in_dom) {
        in_dom = false;
        observer.disconnect();
    }
});
observer.observe(document.body, {childList: true});
// iOS motion sensors text override end

//*****Global Variables START**********************************      
    
    //whether to show debug on screen or not - should be false for clients & staging & production!
    var debugOnVar = false //to use log with the command: AFRAME.log('test')

    //text strings
    var INFO_TEXT1 = "Tippen Sie auf den Bildschirm, um das Portal zu platzieren"  //initial text shown
    var INFO_TEXT2 = "Gehen Sie durch das Portal, um das Erlebnis zu starten" //text shown after placement
    var INFO_TEXT3 = "Machen Sie einen Schritt zur√ºck in Richtung des Portals" //text shown when walking out of balcony
    var sceneLocationTextString = "Highway 1" //text to be shown above the door
    
    
    //experience setup ** THESE CAN BE CHANGED
    var hideDoorOnWalkthrough = false //true means door is hidden when user walks through - Needed for 2nd app demo!!
    var showBalcony = true   //true means balcony is shown
    var videoElsePhoto = false //true means video not photo
    var sceneLocationText = true //true means text will be shown above the door signifying the location
    var doorTriggerDistance = 6  //camera starts around a value of 9. Where a value of 0 = at the door
    var containsDoorAnimation = true //whether door animation exists
    var checkForBalcony = false //if true does a check to see if user has walked off balcony or not (out of bounds) - Currently not used!
    var BalconyWidth = 14 //distance to check if user is out of the balcony in the side (X) direction
    var BalconyDepth = 26  //distance to check if user is out of the balcony in the forward (depth) direction
    var infoURL = "https://www.welt.de/reise/Fern/article205976275/Laenderkunde-Erleben-Sie-Kalifornien-virtuell.html" //URL that info page and share button uses
    var narrativeAudioExists = true // set via template default should be left true
    var infoLinkExists = true // set via template default should be left true
    var containsDoorSpawningSound = true // whether to play a door spawning sound - set via template default should be left true
    var wireFrameColor = 0x00507F
    var modelScaleFactor = 2.6 //you may need to adjust abovePortalHiderWall position Y if you change this

    //global logic vars ** DO NOT CHANGE THESE
    var isInPortalSpace = false
    var wasOutside = true
    var withinPortalBounds = false
    var doorOpened = false
    var resetSceneTriggered = false //called for proper reset of the hide door when walking through scenerio
    var outofBoundsY = false  //if user is out of the balcony in the forward (depth) direction
    var outofBoundsX = false //if user is out of the balcony in the side (X) direction
    var doorVisible = false
    var materialOriginalDoor = new THREE.MeshStandardMaterial({})
    var materialOriginalDoorL = new THREE.MeshStandardMaterial({})
    var materialOriginalDoorR = new THREE.MeshStandardMaterial({})
    var materialOriginalBalcony = new THREE.MeshStandardMaterial({})
    var rotationy = 0
    var alreadyMoved = false
    var openMenu = false
    var playNarrativeAudio = true
    

//*****Global Variables END************************************


      // Checking if camera permissions have been excepted - if so fire tracking event
      AFRAME.registerComponent('camera-status-check', {
        init: function(){
          switch (trackingProvider) {
      			case "Tealium":
      				utag.link({ "event_name" : "ar", "event_action": "ar_initialized"});
      				break;
    		  }
          var handleCameraStatusChange = function handleCameraStatusChange(event) {
          //console.log('status change', event.detail.status);
      
        switch (event.detail.status) {
          case 'requesting':
            // Do something
            break;
      
          case 'hasStream':
            switch (trackingProvider) {
        			case "Tealium":
        				utag.link({ "event_name" : "ar", "event_action": "ar_loaded", "event_label": "consent to use camera given"});
        		}
            //console.log('camera has stream')
            break;
      
          case 'failed':
            //event.target.emit('realityerror');
            //break;
        }
      };
      let scene = this.el.sceneEl
      scene.addEventListener('camerastatuschange', handleCameraStatusChange)

        }
        })
        
       AFRAME.registerComponent('door-seen-by-camera', {
          init: function() {
           this.camera = 0;
            
            this.el.addEventListener("loaded", (e) => {
              setTimeout((e) => {
                //console.log(this.el.camera)
                console.log("camera about to be set")
                this.camera = document.getElementById('camera')
                this.camera = this.el.camera
                console.log("camera set")
              }, 500)
            })
          },
          tick: function() {
            if (this.camera !== 0) {
              var frustum = new THREE.Frustum();
              //console.log("frustum about to be set")
              frustum.setFromMatrix(new THREE.Matrix4().multiplyMatrices(this.el.camera.projectionMatrix, this.el.camera.matrixWorldInverse));
              //frustum.setFromMatrix(new THREE.Matrix4().multiplyMatrices(document.getElementById('camera').object3D.projectionMatrix, document.getElementById('camera').object3D.matrixWorldInverse));
              
              //console.log("frustum set")
              // Your 3d point to check
              //var pos = new THREE.Vector3(0, 0, 0);
              //this.door = document.getElementById('doorEntity')
              //this.door = this.el.door
              
              //var doorEntity = document.getElementById('doorEntity').el.object3D
              //console.log("this")
              //console.log(document.getElementById('doorEntity').el.projectionMatrix)
              //if (frustum.containsPoint(pos)) {
              //if (frustum.intersectsObject(document.getElementById('doorEntity').el.object3D)) {
                 
              //  console.log("hello")
              //}
            }
          }
      })

      // This component hides and shows certain elements as the camera moves as well as info text and balcony
      AFRAME.registerComponent('portal', {
        schema: {
          width: {default: 6},
          height: {default: 30}, //To do: make this dynamic
          depth: {default: 1}, //TO DO: check this value
        },
        init: function(){

          this.camera = document.getElementById('camera')
          this.contents = document.getElementById('portal-contents')
          this.walls = document.getElementById('hider-walls')
          this.portalWall = document.getElementById('portal-return-opening')
          this.portalWorld = document.getElementById('portal-world')
          this.video = document.getElementById('videosphere')
          this.photo = document.getElementById('photosphere')
          
          //get sceneHolder distance
          this.sceneholder = document.getElementById('scene-holder')
          depthOffset = this.sceneholder.getAttribute('position').z
          newX = this.sceneholder.getAttribute('position').x
          newY = this.sceneholder.getAttribute('position').y
          newZ = this.sceneholder.getAttribute('position').z
          intialCameraPositionX = this.camera.getAttribute('position').x
          intialCameraPositionY = this.camera.getAttribute('position').y
          intialCameraPositionZ = this.camera.getAttribute('position').z 

          outofboundsBackground = document.getElementById('outofboundsBackground')
          
          //XR8.XrController.configure({disableWorldTracking: false}) //does not work with 8th wall currently
          
        },
        tick: function() {
          const position = this.camera.object3D.position
          depthOffset = this.sceneholder.getAttribute('position').z
          var isOutside = position.z  > ((this.data.depth / 2) + depthOffset)
          //var rotationy = this.camera.getAttribute('rotation').y + 180
          
          //within width of the door:     //old: const withinPortalBounds = position.y < this.data.height && Math.abs(position.x) < this.data.width / 2
          const withinPortalBounds = (position.x < (this.sceneholder.getAttribute('position').x + (this.data.width / 2)) && position.x > (this.sceneholder.getAttribute('position').x) - (this.data.width / 2) ) 
          //console.log(withinPortalBounds)

        //check if reset scene has been triggered
          if (resetSceneTriggered) {
               
               alreadyMoved = false
               outofBoundsY = false
               outofBoundsX = false
               isInPortalSpace = false
               isOutside = true
               if (hideDoorOnWalkthrough) {
                  //through door show  door
                  document.getElementById('doorEntity').setAttribute('visible', 'true')
                  document.getElementById('balcony').setAttribute('visible', 'true')
              }
              outofboundsBackground.style.backgroundColor = 'rgba(0, 0, 0, 0)';
              resetSceneTriggered = false
          }
          
          
        // check if user has walked into portal
          if (!isInPortalSpace && !isOutside && withinPortalBounds && doorVisible) {
                isInPortalSpace = true
                portalCameraPositionX = this.camera.getAttribute('position').x
                portalCameraPositionY = this.camera.getAttribute('position').y
                portalCameraPositionZ = this.camera.getAttribute('position').z
                
                //model height (used in mode 2)
                modelPositionFirstIntoPortalY = this.sceneholder.getAttribute('position').y
                
                //AFRAME.log(this.camera.object3D.rotation)
                //rotationy = this.camera.getAttribute('rotation').y + 180
                //if ((rotationy - 180) < 0) { 
                //    rotationy = (rotationy - 180) + 360 
                //} else {
                //  rotationy = rotationy - 180
                //}
                //AFRAME.log('Into portal: opposite rotation = ' + rotationy)
                //getWorldPosition(position); .getAttribute('rotation')
                
                //hide stuff:
                //through door hide info text
                //document.getElementById('infoText').object3D.visible = false
                document.getElementById('infoText').textContent = ""
                //through door hide arrow
                document.getElementById('arrow-image-holder').setAttribute('visible', 'false')
                
              if (hideDoorOnWalkthrough) {
                //through door hide door
                document.getElementById('doorEntity').setAttribute('visible', 'false')
                document.getElementById('balcony').setAttribute('visible', 'false')
                this.portalWall.object3D.visible = false
              }
              
              //play narrative sound
              if (playNarrativeAudio && narrativeAudioExists) {
                var soundEntity = document.querySelector('#soundcue')
                soundEntity.components.sound.playSound();
              }  
              switch (trackingProvider) {
      				  case "Tealium":
        					utag.link({ "event_name" : "ar", "event_action": "user_walked_through_portal"});
        				  break;
      			  }
              
              //test to disable world tracking
              //XR8.stop()
              //XR8.XrController.configure({disableWorldTracking: false})
          
        //else check if user has walked out of portal
          } else if (isInPortalSpace && isOutside) {
              //AFRAME.log('walked out of portal')
              isInPortalSpace = false
              isOutside = true
              //hide door when walking out
              document.getElementById('boxInFrontOfDoor').setAttribute('visible', 'true')
              document.getElementById('boxInFrontOfDoor').setAttribute('scale', {x:20, y:76, z:15})
              document.getElementById('doorEntity').setAttribute('visible', 'false')
              document.getElementById('balcony').setAttribute('visible', 'false')
              this.video.object3D.visible = false
              this.photo.object3D.visible = false
              
              //check if video is playing then stop it
              if (videoElsePhoto){
                 //stop video
                 var videoPlayer = document.querySelector('#videosphere').components.material.material.map.image;
                 if (videoPlayer) { 
                      videoPlayer.pause();
                      console.log('stopping video')
                 }
              }
              //reset narrative audio
              if (playNarrativeAudio && narrativeAudioExists) {
                var soundEntity = document.querySelector('#soundcue')
                soundEntity.components.sound.stopSound();
              }  

              
              //set info text1
              document.getElementById('infoText').textContent = INFO_TEXT1
                
              doorVisible = false
          }
          
        //Mode1: reappear door check if opposite rotation and user in portal - not used could be removed
             if ((Math.abs(this.camera.getAttribute('rotation').y + 180 - rotationy) < 60 ) && isInPortalSpace && !alreadyMoved && hideDoorOnWalkthrough){
                alreadyMoved = true
                //AFRAME.log('reshow')
                //AFRAME.log('camera position = ' + this.camera.getAttribute('position').x + ', ' + (this.camera.getAttribute('position').y - intialCameraPositionY) + ', z - 10' + (this.camera.getAttribute('position').z + 10))
                //set new Y
                if ((this.camera.getAttribute('position').y - intialCameraPositionY) < -3) {
                   newY = -3 //this value is taken from the scenelocation Y
                } else {
                  newY = this.camera.getAttribute('position').y - intialCameraPositionY
                }
                //set new X
                if ((Math.abs(this.camera.getAttribute('rotation').y + 180 - rotationy) > 30 )) {
                  newX = this.camera.getAttribute('position').x - 3.5
                } else if ((Math.abs(this.camera.getAttribute('rotation').y + 180 - rotationy) > 30 )) {
                  newX = this.camera.getAttribute('position').x + 3.5
                }
                lookAtX = this.camera.getAttribute('position').x
                // set new Z
                newZ = this.camera.getAttribute('position').z + 10
                
                this.sceneholder.setAttribute('position', {x: newX, y: newY, z: newZ});
                //this.sceneholder.object3D.lookAt(lookAtX, newY, newZ)
                //this.sceneholder.setAttribute('rotation', {x: (this.camera.getAttribute('rotation').x - 90), y: this.camera.getAttribute('rotation').y, z: this.camera.getAttribute('rotation').z});
                
                document.getElementById('doorEntity').setAttribute('visible', 'true')
                document.getElementById('balcony').setAttribute('visible', 'true')
                this.portalWall.object3D.visible = true
  
            } 
            else if (((Math.abs(this.camera.getAttribute('rotation').y + 180 - rotationy) > 120 ) && isInPortalSpace && alreadyMoved) || ((Math.abs(this.camera.getAttribute('rotation').y + 180 - rotationy) > 60 ) && !isInPortalSpace && alreadyMoved)) { //hide door again 2nd case for catching edge case of out of portal bug
                alreadyMoved = false
                //AFRAME.log('hide')
                document.getElementById('doorEntity').setAttribute('visible', 'false')
                document.getElementById('balcony').setAttribute('visible', 'false')
                this.portalWall.object3D.visible = false
            }
          
        //Mode2: stick portal to camera if inside portal
            if (isInPortalSpace && !hideDoorOnWalkthrough){
                //AFRAME.log(Math.abs(this.camera.getAttribute('position').z - portalCameraPositionZ))
                
                //set x for sceneHolder
                if ((this.camera.getAttribute('position').x - portalCameraPositionX) > BalconyWidth) {
                    newX = this.camera.getAttribute('position').x - BalconyWidth
                } else if ((this.camera.getAttribute('position').x - portalCameraPositionX) < -BalconyWidth) {
                    newX = this.camera.getAttribute('position').x + BalconyWidth
                    if (!outofBoundsX) {
                      //AFRAME.log('out of balcony X');
                      outofBoundsX = true
                      //change text / reshow
                      //document.getElementById('infoText').setAttribute('text', 'value: ' + INFO_TEXT3)
                      //document.getElementById('infoText').object3D.visible = true
                      document.getElementById('infoText').textContent = INFO_TEXT3
                      
                      outofboundsBackground.style.backgroundColor = 'rgba(0, 0, 0, 0.6)'
                  }
                } else {
                    newX = this.sceneholder.getAttribute('position').x
                    if (outofBoundsX) {
                      AFRAME.log('in balcony again X');
                      outofBoundsX = false
                      //hide out of bounds text
                      //document.getElementById('infoText').object3D.visible = false
                      document.getElementById('infoText').textContent = ""
                      
                      outofboundsBackground.style.backgroundColor = 'rgba(0, 0, 0, 0)'
                    }
                }
                //Check for correct Z (distance from camera)
                if (this.camera.getAttribute('position').z - portalCameraPositionZ < - BalconyDepth) {
                  //AFRAME.log('stuck on z: ' + (this.camera.getAttribute('position').z - portalCameraPositionZ))
                  newZ = this.camera.getAttribute('position').z + BalconyDepth
                  if (!outofBoundsY) {
                      //AFRAME.log('out of balcony Y');
                      outofBoundsY = true
                      //change text / reshow
                      //document.getElementById('infoText').setAttribute('text', 'value: ' + INFO_TEXT3)
                      //document.getElementById('infoText').object3D.visible = true
                      document.getElementById('infoText').textContent = INFO_TEXT3
                      
                      outofboundsBackground.style.backgroundColor = 'rgba(0, 0, 0, 0.6)'
                  }
                } else {
                  newZ = this.sceneholder.getAttribute('position').z
                  //this.sceneholder.setAttribute('position', {x: this.camera.getAttribute('position').x, y: -1, z: this.sceneholder.getAttribute('position').z})  
                  if (outofBoundsY) {
                      //AFRAME.log('in balcony again Y');
                      outofBoundsY = false
                      //hide out of bounds text
                      //document.getElementById('infoText').object3D.visible = false
                      document.getElementById('infoText').textContent = ""
                      
                      outofboundsBackground.style.backgroundColor = 'rgba(0, 0, 0, 0)'
                  }
                }
                
                //check for Y using modelPositionFirstIntoPortalY
                if ((this.camera.getAttribute('position').y) < 1) { // this.sceneholder.getAttribute('position').y
                 //   AFRAME.log('Y less than -1: ' + (this.camera.getAttribute('position').y))
                    newY = modelPositionFirstIntoPortalY
                //    AFRAME.log('Y great than 10: ' + (this.camera.getAttribute('position').y))
                //    newY = this.camera.getAttribute('position').y - 12his.camera.getAttribute('position').y - 10, z: this.sceneholder.getAttribute('position').z})  
                } else if ((this.camera.getAttribute('position').y - modelPositionFirstIntoPortalY) > 20) {
                  //  AFRAME.log('Y greater than ' + (this.camera.getAttribute('position').y))
                   newY = (this.camera.getAttribute('position').y - modelPositionFirstIntoPortalY) - this.camera.getAttribute('position').y
                }  else {
                 // AFRAME.log('Y in range ' + (this.camera.getAttribute('position').y))
                  newY = modelPositionFirstIntoPortalY
                }
                //set resulting position
                this.sceneholder.setAttribute('position', {x: newX, y: newY, z: newZ})  
  
            }
          
        //door animation check
          if ((position.z < doorTriggerDistance) && !doorOpened && containsDoorAnimation && doorVisible) {
              doorOpened = true
              //console.log('door opened')
              document.querySelector('#doorEntityL').emit('open')
              document.querySelector('#doorEntityR').emit('open')
              document.querySelector('#doorOpenSoundCue').components.sound.stopSound()
              document.querySelector('#doorOpenSoundCue').components.sound.playSound()
          } else if ((position.z > doorTriggerDistance) && doorOpened && containsDoorAnimation && doorVisible) {
              doorOpened = false
              //console.log('door closed')
              document.querySelector('#doorEntityL').emit('close')
              document.querySelector('#doorEntityR').emit('close')
              document.querySelector('#doorOpenSoundCue').components.sound.stopSound()
              document.querySelector('#doorOpenSoundCue').components.sound.playSound()
          }
          //end door animation check
          
          //console.log('isInPortalSpace = ' + isInPortalSpace + ', isOutside = ' + isOutside)
        //set visibilities of portal components
          this.contents.object3D.visible = isInPortalSpace || isOutside
          this.walls.object3D.visible = !isInPortalSpace && isOutside
          if (!hideDoorOnWalkthrough) { this.portalWall.object3D.visible = isInPortalSpace && !isOutside }
          this.portalWorld.object3D.visible = isInPortalSpace

          wasOutside = isOutside
          
        }
      })



 //This component plays the video on screen tap if it doesn't autoplay and resets the tracking on screentap
    AFRAME.registerComponent('touchscreen-handler', {
      init: function() {
           
            const uiContainer = document.getElementById('uiContainer')
            const closeButton = document.getElementById('placeholderButton')
            const tapScreen = document.getElementById('tapScreenButton')
            const sceneHolder = document.getElementById('scene-holder')
            const camera = document.getElementById('camera')

            //tap screen listener for non-specific components:
            tapScreen.addEventListener('click', () => {
                  console.log('tapScreen pressed')
                  
                  if (!isInPortalSpace || outofBoundsY || outofBoundsX) {
                    // recenter scene, camera and sceneHolder
                    let scene = this.el.sceneEl
                    //scene.emit('recenter')
                    scene.emit('recenter', {
                        origin: {x: 0, y: 12, z: 8}
                     })
                    //scene.emit('recenter', {
                    //    origin: {x: 0, y: 8, z: 8},
                    //    facing: {w: 0, x:0, y:0, z:0}
                    // })
                    camera.setAttribute('position', {x: 0, y: 12, z: 8})
                    sceneHolder.setAttribute('position', {x: 0, y: -3, z: -15})
                    //AFRAME.log('scene-holder postion: x:' + sceneHolder.getAttribute('position').x + ', y:' + sceneHolder.getAttribute('position').y + ',z:' + sceneHolder.getAttribute('position').z)
                    //this.sceneholder.setAttribute('position', {x: this.camera.getAttribute('position').x, y: -1, z: this.camera.getAttribute('position').z - 10})
                    resetSceneTriggered = true  //reseting some other vars in the portal ontick
                    
                    //reset narrative audio
                    var soundEntity = document.querySelector('#soundcue')
                    soundEntity.components.sound.stopSound();
                    
                   // //check if video is playing yet
                   // if (videoElsePhoto){
                   //   //play video
                   //   var video = document.querySelector('#videosphere').components.material.material.map.image;
                   //   if (!video) { return; }
                   //   video.play();
                   //  }
                  }    
            })  //end tap screen eventhandler
          
      }
    });

   
   //This handles starting the show door animation on a screen tap
    AFRAME.registerComponent('show-door-ani-on-tap', {
      init: function() {
         const tapScreen = document.getElementById('tapScreenButton')
         //tap screen listener:
            tapScreen.addEventListener('click', () => {
                   
                  //Door & Balcony: material change
                  if (!isInPortalSpace || outofBoundsY || outofBoundsX) { 
                        
                        
                        //set wirefirame materials door:
                          let eldoor = document.getElementById('doorEntity');
                          let meshDoor = eldoor.getObject3D('mesh'); 
                          if (!meshDoor){return;}
                          //console.log(mesh);
                          meshDoor.traverse(function(node){
                             if (node.isMesh){  
                               //let materialOriginalDoor = node.material
                               node.material = new THREE.MeshStandardMaterial({
                                  color : wireFrameColor,
                                 wireframe : true,
                                 emissive:  wireFrameColor,
                                 emissiveIntensity: 10,
                                 opacity : 1
                               });
                             }
                          });
                          //set wireframe materials balcony:
                          if (showBalcony) {
                              let elbalcony = document.getElementById('balcony');
                                let meshBalcony = elbalcony.getObject3D('mesh'); 
                                if (!meshBalcony){return;}
                                //console.log(mesh);
                                meshBalcony.traverse(function(node){
                                   if (node.isMesh){  
                                     //let materialOriginalBalcony = node.material
                                     node.material = new THREE.MeshStandardMaterial({
                                        color : wireFrameColor,
                                       wireframe : true,
                                       emissive:  wireFrameColor,
                                       emissiveIntensity: 10,
                                       opacity : 1
                                     });
                                   }
                                });        
                          }
                          if (containsDoorAnimation) {
                                let eldoorL = document.getElementById('doorEntityL');
                                let meshDoorL = eldoorL.getObject3D('mesh'); 
                                if (!meshDoorL){return;}
                                //console.log(mesh);
                                meshDoorL.traverse(function(node){
                                   if (node.isMesh){  
                                      //let materialOriginalDoorL = node.material
                                      node.material = new THREE.MeshStandardMaterial({
                                        color : wireFrameColor,
                                       wireframe : true,
                                       emissive:  wireFrameColor,
                                       emissiveIntensity: 10,
                                       opacity : 1
                                     });
                                   }
                                });  
                                let eldoorR = document.getElementById('doorEntityR');
                                let meshDoorR = eldoorR.getObject3D('mesh'); 
                                if (!meshDoorR){return;}
                                //console.log(mesh);
                                meshDoorR.traverse(function(node){
                                   if (node.isMesh){  
                                      //let materialOriginalDoorR = node.material
                                      node.material = new THREE.MeshStandardMaterial({
                                        color : wireFrameColor,
                                       wireframe : true,
                                       emissive:  wireFrameColor,
                                       emissiveIntensity: 10,
                                       opacity : 1
                                     });
                                   }
                                });   
                          }
                          
                  
                        //hide info text and arrow while door is animating
                        //document.getElementById('infoText').object3D.visible = false
                        document.getElementById('infoText').textContent = ""
                        document.getElementById('arrow-image-holder').setAttribute('visible', 'false')
                        
                        //hide video sphere
                        if (videoElsePhoto) {
                          if (document.getElementById('videosphere').object3D.visible) {
                            document.getElementById('videosphere').object3D.visible = false;
                          }
                        }
                        else { 
                          if (document.getElementById('photosphere').object3D.visible) {
                            document.getElementById('photosphere').object3D.visible = false;
                          }
                        }
                        //hide balcony if we have inner doors else show if exists
                        if (showBalcony && containsDoorAnimation) { document.getElementById('balcony').setAttribute('visible', 'false') }
                        else if (showBalcony) { document.getElementById('balcony').setAttribute('visible', 'true') }

                        
                        //start animation of box hider
                        document.getElementById('boxInFrontOfDoor').emit('showportal')
                        document.getElementById('boxInFrontOfDoor').setAttribute('visible', 'true')
                        document.getElementById('doorEntity').setAttribute('visible', 'true')
                        if (containsDoorSpawningSound) { 
                          document.querySelector('#doorSpawnSoundCue').components.sound.stopSound()
                          document.querySelector('#doorSpawnSoundCue').components.sound.playSound() 
                        }
                  }
            })
      }
    });


 //This handles the logic for when the show door animation is complete
    AFRAME.registerComponent('show-door-ani-over-logic', {
      init: function() {
      
          document.getElementById('boxInFrontOfDoor').addEventListener('animationcomplete', (e) => {
          //console.log(e.detail.name);
                                    
          if (e.detail.name == 'animation__showportal') {
                 //console.log('show portal done')
                 document.getElementById('boxInFrontOfDoor').setAttribute('visible', 'false')
                 
                  let eldoor = document.getElementById('doorEntity');
                  let meshDoor = eldoor.getObject3D('mesh'); 
                  if (!meshDoor){return;}
                  meshDoor.traverse(function(node){
                    if (node.isMesh){  
                      node.material = materialOriginalDoor
                    }
                  });
            if (showBalcony) {
                  let elbalcony = document.getElementById('balcony');
                  let meshBalcony = elbalcony.getObject3D('mesh'); 
                  if (!meshBalcony){return;}
                  meshBalcony.traverse(function(node){
                     if (node.isMesh){  
                       node.material = materialOriginalBalcony
                     }
                  });
                }
            if (containsDoorAnimation) {
              let elDoorL = document.getElementById('doorEntityL');
              let meshDoorL = elDoorL.getObject3D('mesh'); 
              if (!meshDoorL){return;}
               meshDoorL.traverse(function(node){
               if (node.isMesh){  
                       node.material = materialOriginalDoorL
                      // console.log("set l door material")
                     }
                  });
               
               let eldoorR = document.getElementById('doorEntityR');
               let meshDoorR = eldoorR.getObject3D('mesh'); 
               if (!meshDoorR){return;}
               meshDoorR.traverse(function(node){
               if (node.isMesh){  
                       node.material = materialOriginalDoorR
                     }
                  });
            }
            doorVisible = true
            
            //change text / reshow
            //document.getElementById('infoText').setAttribute('text', 'value: ' + INFO_TEXT2)
            //document.getElementById('infoText').object3D.visible = true
            document.getElementById('infoText').textContent = INFO_TEXT2
            //show arrow
            document.getElementById('arrow-image-holder').setAttribute('visible', 'true')
            
             //show video sphere
           if (videoElsePhoto) {
                          if (!document.getElementById('videosphere').object3D.visible) {
                            document.getElementById('videosphere').object3D.visible = true;
                          }
                        }
                        else { 
                          if (!document.getElementById('photosphere').object3D.visible) {
                            document.getElementById('photosphere').object3D.visible = true;
                          }
                        }
            //show balcony
            if (showBalcony && containsDoorAnimation) { document.getElementById('balcony').setAttribute('visible', 'true') }

            
             //check if video is playing yet
              if (videoElsePhoto){
                //play video
                var video = document.querySelector('#videosphere').components.material.material.map.image;
                if (!video) { return; }
                video.play();
               }
            
            //send tracking event
            switch (trackingProvider) {
      				case "Tealium":
      					utag.link({ "event_name" : "ar", "event_action": "user_placed_portal"});     
      				break;
      			}    
          }
        }) 
      }
    })
 
      //This hides video/photo sphere inside the initial hider box in case user walks in there before spawning door
    AFRAME.registerComponent('hide-after-load', {         
          init: function () {
             // After entity has loaded scale down to make 'invisible'
            this.el.addEventListener('loaded', (e) => {

                this.el.object3D.visible = false;
            })
          }
     })


    //This shows models on tap
    AFRAME.registerComponent('scaleup-on-tap', {         
          init: function () {
            const tapScreen = document.getElementById('tapScreenButton')
            //tap screen listener:
            tapScreen.addEventListener('click', () => {
                if (!isInPortalSpace || outofBoundsY || outofBoundsX) {
                  this.el.object3D.scale.set(modelScaleFactor, modelScaleFactor, modelScaleFactor); //this causes a flash if use walks through door and spawns from other side - could be moved for this edge case
                }
            })
          }
     })  
     

    //This saves the original material of the door and balcony models
    AFRAME.registerComponent('save-orginal-model-material', {         
          init: function () {
             // After gltf model has loaded,save it's default material
            let eldoor = document.getElementById('doorEntity');
            eldoor.addEventListener('model-loaded', function(ev){
              let meshDoor = eldoor.getObject3D('mesh'); 
              if (!meshDoor){return;}
              meshDoor.traverse(function(node){
                 if (node.isMesh){  
                   materialOriginalDoor = node.material
                   
                 }
              });
            });
            if (showBalcony) {
                elbalcony = document.getElementById('balcony');
                elbalcony.addEventListener('model-loaded', function(ev){
                  let meshBalcony = elbalcony.getObject3D('mesh'); 
                  if (!meshBalcony){return;}
                  meshBalcony.traverse(function(node){
                     if (node.isMesh){  
                       materialOriginalBalcony = node.material
                       
                     }
                  });
                });
            }
            if (containsDoorAnimation) {
                eldoorL = document.getElementById('doorEntityL');
                eldoorL.addEventListener('model-loaded', function(ev){
                  let meshDoorL = eldoorL.getObject3D('mesh'); 
                  if (!meshDoorL){return;}
                  meshDoorL.traverse(function(node){
                     if (node.isMesh){  
                       materialOriginalDoorL = node.material
                       
                     }
                  });
                });
                eldoorR = document.getElementById('doorEntityR');
                eldoorR.addEventListener('model-loaded', function(ev){
                  let meshDoorR = eldoorR.getObject3D('mesh'); 
                  if (!meshDoorR){return;}
                  meshDoorR.traverse(function(node){
                     if (node.isMesh){  
                       materialOriginalDoorR = node.material
                       
                     }
                  });
                });
            }
          }
        });

        

      // This component gives the invisible hider walls the property they need
      AFRAME.registerComponent('hider-material', {
        init: function() {
          const mesh = this.el.getObject3D('mesh')
          mesh.material.colorWrite = false
        },
      })

      // To set the initial info text
      AFRAME.registerComponent('set-initial-info-text', {
        init: function() {
          //this.el.setAttribute('text', 'value: ' + INFO_TEXT1)
          document.getElementById('infoText').textContent = INFO_TEXT1
          document.getElementById('infoText').style.display = "block"; 
        },
      })
      
      
    
    
      //To hide or show  the sceneLocationText above door
      AFRAME.registerComponent('scenelocation_textholder_controller', {
        init: function() {
          
          if (sceneLocationText) {
            document.getElementById('sceneLocationTextHolder').setAttribute('visible', 'true')
          } else {
            document.getElementById('sceneLocationTextHolder').setAttribute('visible', 'false')
          }
        },
         
      });
      
      //to set the text of the scenelocationText entitys
        AFRAME.registerComponent('scenelocation_text_setter', {
        init: function() {
            if (sceneLocationText) {
            this.el.setAttribute('text', 'value: ' + sceneLocationTextString + ';')
          }
        },
         
      })
    
    //to show either photo or video sphere
     AFRAME.registerComponent('photo-or-video', {
        init: function() {
          if (videoElsePhoto) {
            document.querySelector("#photosphere").setAttribute('visible', 'false')

          } else {
            document.querySelector("#videosphere").setAttribute('visible', 'false')
          }
          
        },
      })
    
 
    
              
    
   

    
 // To handle the looping arrow-animation
      AFRAME.registerComponent('arrow-ani-setup', {
        init: function() {
          var arrow1 = document.querySelector('#arrow1')
          //var arrow2 = document.querySelector('#arrow2')
          //var arrow3 = document.querySelector('#arrow3')
          this.el.addEventListener('loaded', (e) => {
              //console.log('loaded')
              arrow1.emit('moveup');
              //setTimeout(function(){ arrow2.emit('moveup'); }, 400);
              //setTimeout(function(){ arrow3.emit('moveup'); }, 800);
          })
        },
      })
       
       AFRAME.registerComponent('arrow-ani', {
        init: function() {
          this.el.addEventListener('animationcomplete', (e) => {
            //console.log(e.detail.name);
            if (e.detail.name == 'animation__moveup') {
                this.el.emit('moveup');
                this.el.emit('fadein');
            } 
            if (e.detail.name == 'animation__fadein') {
                  //console.log('fadein done')
                    this.el.emit('fadeout');
                } 
            if (e.detail.name == 'animation__fadeout') {
                  //console.log('fadeout done')
                    this.el.emit('fadein');
                }
          })

      
        },
      })



      // For showing debug logs on screen
      AFRAME.registerComponent('debugon', {
        init: function() {
          this.el.setAttribute('visible', debugOnVar)
        },
      })
      

    //Dynamic Lighting - partially used
      AFRAME.registerComponent('xr-light', {
        schema: {
          min: {default: 0},
          max: {default: 20}
        },
        init: function() {
          const startListen = () => {
            window.XR.XrController.configure({enableLighting: true})
            window.XR.addCameraPipelineModule({
              name: 'xr-light',
              onUpdate: ({processCpuResult}) => {
                if (processCpuResult.reality && processCpuResult.reality.lighting && processCpuResult.reality.lighting.exposure) {
                  this.intensity = 1 + processCpuResult.reality.lighting.exposure
                }
              }
            })
          }

          this.intensity = 1

          window.XR ? startListen() : window.addEventListener('xrloaded', startListen)

          },
        tick: function() {
          let headlights = this.el.sceneEl.querySelectorAll('a-cone')
          var tempIntensity = Math.max(this.data.min, Math.min((this.system.intensity * 10), this.data.max))
          this.el.setAttribute('light', 'intensity: ' + tempIntensity)
          //console.log(tempIntensity)
         
                    
          }
        })




  //Video event handler - used for bufferring checking
    AFRAME.registerComponent('videoeventhandler', {
      init: function() {
          if (videoElsePhoto){
            var video = this.el.components.material.material.map.image;
            console.log('video = ' + video)
            
            //set timer
            var bufferCheckTimer = null;
            var lastBufferProgressTime = 0;
            var bufferCheckValue = 0;
            var stopBufferTimerForGood = false;
             
             //video event testing
                  video.addEventListener('waiting', (event) => {
              console.log('Video is waiting for more data.');
            });
            
                  video.addEventListener('stalled', (event) => {
              console.log('Video is stalled for more data.');
            });
            
            video.addEventListener('playing', (event) => {
              console.log('Video is no longer paused');
            });
            
            video.addEventListener('canplay', (event) => {
              console.log('Video can start, but not sure it will play through.' + video.readyState);
            });
            video.addEventListener('progress', (event) => {
              console.log('resource loading buffered = ' + Math.round(video.buffered.end(0)) + ' of ' + Math.round(video.seekable.end(0)) + ' secs');
              if (Math.round(video.buffered.end(0)) == Math.round(video.seekable.end(0))) {
                  stopBufferTimerForGood = true
              }
              if (!stopBufferTimerForGood) {
                if (lastBufferProgressTime == Math.round(video.buffered.end(0))) {
                  if (bufferCheckTimer == null) {
                      console.log('set timer');
                      bufferCheckValue = Math.round(video.buffered.end(0))
                      bufferCheckTimer = setTimeout(showSlowBufferring(bufferCheckValue), 4000);
                  }
                } else if ((bufferCheckTimer != null) && (Math.round(video.buffered.end(0)) - bufferCheckValue > 2)) {
                    console.log('calling hide buffering')
                    hideSlowBufferring();
                }
                lastBufferProgressTime = Math.round(video.buffered.end(0))
              } else if (bufferCheckTimer != null) {
                    console.log('calling hide buffering for good')
                    hideSlowBufferring();
              }
              
            });
            video.addEventListener('canplaythrough', (event) => {
              console.log('I think I can play through the entire ' + 'video without ever having to stop to buffer.');
              stopBufferTimerForGood = true;
              
            });
            video.addEventListener('loadeddata', (event) => {
              console.log('Yay! The readyState just increased to  ' + 'HAVE_CURRENT_DATA or greater for the first time.');

            });
            
             function showSlowBufferring(bufferCheckValue) {
                 console.log('timer fired = ' + bufferCheckValue + ', against:' + Math.round(video.buffered.end(0)) + ', progress = ' + (Math.round(video.buffered.end(0)) - bufferCheckValue) / Math.round(video.seekable.end(0)) + ' % ')
                 
                 if ((Math.round(video.buffered.end(0)) - bufferCheckValue) < 2) {
                   console.log('showing buffering text')
                  document.getElementById("internetText").style.display = "block"; 
                 }
              }
              function hideSlowBufferring() {
                console.log('timercleared')
                clearTimeout(bufferCheckTimer);
                bufferCheckTimer = null;
                document.getElementById("internetText").style.display = "none"; 
              }
          }
      },
       
    });


 
  //Component to handle Menu interactions and buttons
    AFRAME.registerComponent('menu-interactions', {
      init: function() { 

      //show menu
           $('#uiContainer').css('display', 'block');
           if (!narrativeAudioExists) { $('#audioButton').css('opacity', '0.0'); }
           if (!infoLinkExists) { $('#infoButton').css('opacity', '0.0'); }
           
           //script for swipe up and down
            var supportTouch = $.support.touch,
                        scrollEvent = "touchmove scroll",
                        touchStartEvent = supportTouch ? "touchstart" : "mousedown",
                        touchStopEvent = supportTouch ? "touchend" : "mouseup",
                        touchMoveEvent = supportTouch ? "touchmove" : "mousemove";
                $.event.special.swipeupdown = {
                    setup: function() {
                        var thisObject = this;
                        var $this = $(thisObject);
                        $this.bind(touchStartEvent, function(event) {
                            var data = event.originalEvent.touches ?
                                    event.originalEvent.touches[ 0 ] :
                                    event,
                                    start = {
                                        time: (new Date).getTime(),
                                        coords: [ data.pageX, data.pageY ],
                                        origin: $(event.target)
                                    },
                                    stop;
            
                            function moveHandler(event) {
                                if (!start) {
                                    return;
                                }
                                var data = event.originalEvent.touches ?
                                        event.originalEvent.touches[ 0 ] :
                                        event;
                                stop = {
                                    time: (new Date).getTime(),
                                    coords: [ data.pageX, data.pageY ]
                                };
            
                                // prevent scrolling
                                if (Math.abs(start.coords[1] - stop.coords[1]) > 10) {
                                    event.preventDefault();
                                }
                            }
                            $this
                                    .bind(touchMoveEvent, moveHandler)
                                    .one(touchStopEvent, function(event) {
                                $this.unbind(touchMoveEvent, moveHandler);
                                if (start && stop) {
                                    if (stop.time - start.time < 1000 &&
                                            Math.abs(start.coords[1] - stop.coords[1]) > 30 &&
                                            Math.abs(start.coords[0] - stop.coords[0]) < 75) {
                                        start.origin
                                                .trigger("swipeupdown")
                                                .trigger(start.coords[1] > stop.coords[1] ? "swipeup" : "swipedown");
                                    }
                                }
                                start = stop = undefined;
                            });
                        });
                    }
                };
                $.each({
                    swipedown: "swipeupdown",
                    swipeup: "swipeupdown"
                }, function(event, sourceEvent){
                    $.event.special[event] = {
                        setup: function(){
                            $(this).bind(sourceEvent, $.noop);
                        }
                    };
                });
              //end script for swipe up and down
 
             $('#uiContainer').on('swipedown',function(){
            	console.log("swipedown..");
            	slidingMenu();
            });
            $('#uiContainer').on('swipeup',function(){
            	console.log("swipeup..");
            	slidingMenu();
            } );
            
            $('#carrotContainer').on('click',function(){
            	console.log("open..");
            	slidingMenu();
            });
            //for showing and hiding menu
            function slidingMenu() {
            	if (openMenu) {
            		console.log('hiding');
            		openMenu = false;
            		$('#uiContainer').css('bottom', '-16vmin');
            		$('#carrotContainer').css('transform', 'rotate(0deg)');
            	} else {
            		console.log('showing');
            		openMenu = true;
            		$('#uiContainer').css('bottom', '0vmin');
            		$('#carrotContainer').css('transform', 'rotate(-180deg)');
            	}
            }
            
            //share data for share button
            const shareData = {
              title: 'Shannon test',
              text: '',
              url: infoURL,
            }
            //share button
            $('#shareButton').on('click',function(){
            	try {
            		navigator.share(shareData)
            	  } catch(err) {
            		console.log('Share Error: ' + err);
            	  }
            });
            
            //info button - opens in same tab since leaving breaks gyroscope when returning on android
             if (infoLinkExists) {
                $('#infoButton').on('click',function(){
            	      window.open(infoURL, "_self"); 
            	  });
             }
             
  //audio button for toggling narrative audio on/off
             if (narrativeAudioExists) {
                 var soundEntity = document.querySelector('#soundcue')
                 $('#audioButton').on('click',function(){
                		playNarrativeAudio = !playNarrativeAudio
                	  if (!playNarrativeAudio) {
                	    //stop narrative audio
                      $('#audioButton').css("background-image", "url('./assets/speaking_off_icon_white-lqygci2pia.png')");
                       soundEntity.components.sound.stopSound();
                	  } else {
                	    $('#audioButton').css("background-image", "url('./assets/speaking_icon_white-yhdqgbt9rh.png')");
                	  }
                	  if (isInPortalSpace && playNarrativeAudio) {
                	    soundEntity.components.sound.playSound() //turn sound back on
                	  }
                });
            }
      },
    });
    
        
  //This pauses the sound when minimized / screen turned off closed
  $(window).focus(function() {
      // Unpause when window gains focus
      if (isInPortalSpace && playNarrativeAudio) {
        var soundEntity = document.querySelector('#soundcue')
        soundEntity.components.sound.playSound()
      }
      //console.log('gained focus')
  }).blur(function() {
      // stop when window loses focus - unable to pause as does not resume properly on iOS
      if (isInPortalSpace && playNarrativeAudio) {
        var soundEntity = document.querySelector('#soundcue')
        soundEntity.components.sound.stopSound()
        
      }
      //console.log('lost focus')
  });
  
	</script>
<!-- Copyright (c) 2020 Headgear -->

 <!-- These HTML elements are used to show an UI laid over the scene -->
      <div id="tapScreenButton"></div>
      <div id="uiContainer">
        	<div id="carrotContainer">^</div>
        	<div id="shareButtonContainer">
        		<div id="shareButton"></div>
        	</div>  
        	<div id="audioButtonContainer">
        		<div id="audioButton"></div>
        	</div>  
        	<div id="infoButtonContainer">
        		<div id="infoButton"></div>
        	</div>  
      </div>
      <div id="infoText"></div>
      <div id="internetText" style="display:none;">Bitte √ºberpr√ºfen Sie Ihre Internetverbindung,<br>um die volle Erlebnisreise zu streamen.</div>
      <div id="outofboundsBackground"></div>
      
<!-- aframe scene components -->

 <a-scene id="scene"
 light="defaultLightsEnabled: true"
 renderer="colorManagement: true;
            sortObjects: false;"
      xrextras-almost-there
      xrextras-loading
      xrextras-runtime-error
      camera-status-check
      touchscreen-handler
      menu-interactions
      photo-or-video
      set-initial-info-text
      xrweb> <!-- stats  -->

      <!-- We can define assets here to be loaded when A-Frame initializes -->
      <a-assets>
       
      <!--  <a-asset-item id="doorModel" src="./assets/door230cm.glb"></a-asset-item>   -->
        <a-asset-item id="doorModel" src="./assets/wams_gate_frame.glb"></a-asset-item> 
        <a-asset-item id="balconyModel" src="./assets/wams_balcony.glb"></a-asset-item> 

        <a-asset-item id="door_l" src="./assets/wams_door_L.glb"></a-asset-item>
        <a-asset-item id="door_r" src=""./assets/wams_door_R.glb"></a-asset-item>
        <a-asset-item id="door_l_window" src="./assets/wams_window_L.glb"></a-asset-item>
        <a-asset-item id="door_r_window" src="./assets/wams_window_R.glb"></a-asset-item>

		<video id="video1" src=""
          loop crossorigin="anonymous" preload="auto" playsinline webkit-playsinline></video>
   

        <img id="arrowhead-image" src="./assets/arrowhead.png">
        
          <!-- asset for 360 photo and or video poster -->
        <img id="photo" src="./assets/video_thumbnail.jpg">

         <!-- Audio Assets -->
         <!-- asset for narrator -->
        <audio id="audio" src="./assets/sea_elephants_Robben_AR.mp3" preload="auto"></audio>
         <!-- asset for door spawning sound -->
        <audio id="doorSpawningAudio" src="./assets/door_spawning_sound.mp3" preload="auto"></audio>
         <!-- asset for door opening sound -->
        <audio id="doorOpeningAudio" src="./assets/door_opening_sound.mp3" preload="auto"></audio>
        
      </a-assets>
        
      
   
       <a-camera
        id="camera"
        position="0 12 12"> <!-- changing the depth/height (y) and distance (z) of the camera results in a rescale of the door -->
           
          <a-entity id="arrow-image-holder" visible="false" arrow-ani-setup>
             <a-image id="arrow1" position="0 0.025 -1" scale="0.1 0.2 0.1" src="#arrowhead-image" transparent="true" shader="flat" opacity="0.0" material="alphaTest: 0.5"
                          animation__moveup="property: position; from: 0 0.025 -1; to: 0 0.4 -1.5; dur: 2000; startEvents: moveup; easing: easeInOutQuad "
                          animation__fadein="property: material.opacity; from: 0.0; to: 1.0; startEvents: animtioncomplete__moveup; dur: 1000; startEvents: fadein; easing: easeInOutQuad"
                           animation__fadeout="property: material.opacity; from: 1.0; to: 0.0; dur: 1000; startEvents: animationcomplete__fadein; startEvents: fadeout; easing: easeInOutQuad "
                          
                           arrow-ani>
              </a-image>  
              <!-- for multiple arrows:
              <a-image id="arrow2" position="0 0.025 -1" scale="0.1 0.1 0.1" src="#arrowhead-image" transparent="true" shader="flat" opacity="0.0"
                          animation__moveup="property: position; from: 0 0.025 -1; to: 0 0.4 -1; dur: 2000; startEvents: moveup; easing: easeInOutQuad"
                          animation__fadein="property: material.opacity; from: 0.0; to: 1.0; startEvents: animtioncomplete__moveup; dur: 1000; startEvents: fadein; easing: easeInOutQuad"
                           animation__fadeout="property: material.opacity; from: 1.0; to: 0.0; dur: 1000; startEvents: animationcomplete__fadein; startEvents: fadeout; easing: easeInOutQuad"
                          
                           arrow-ani>
              </a-image>  
              <a-image id="arrow3" position="0 0.025 -1" scale="0.1 0.1 0.1" src="#arrowhead-image" transparent="true" shader="flat" opacity="0.0"
                          animation__moveup="property: position; from: 0 0.025 -1; to: 0 0.4 -1; dur: 2000; startEvents: moveup; easing: easeInOutQuad "
                          animation__fadein="property: material.opacity; from: 0.0; to: 1.0; startEvents: animtioncomplete__moveup; dur: 1000; startEvents: fadein; easing: easeInOutQuad"
                           animation__fadeout="property: material.opacity; from: 1.0; to: 0.0; dur: 1000; startEvents: animationcomplete__fadein; startEvents: fadeout; easing: easeInOutQuad "
                          
                           arrow-ani>
              </a-image >  
              -->
          </a-entity> 
        <!-- markOT-qmqk8fajid.glb 
              <a-entity
            id="infoText"
            text="align: center; value: Tor platzieren; color: white; wrapCount: 22; font: ./assets/markOToutline-lp1gchdrai.glb;" 
            position="0 -0.1 -1"
            scale="0.5 0.5 0.5"
            set-initial-info-text>
          </a-entity>
              -->
     
          </a-camera> 

 <!-- main scene holder - used to push door further back on spawn. NOTE: changing Z results in having to move the camera Y up or down -->
      <a-entity id="scene-holder" position="0 -3 -50" portal>
        
            <!--  Lights -->
          <a-entity
            light="type: directional;
                   intensity: 1;
                   target: #doorEntity;"
            position="1 15 8"
          ></a-entity>
          <a-light type="ambient" intensity="1"></a-light>
           
            <!-- box in front of door for ani in: wScale effected by width of door. yPosition & ySacle (set also in ani) effected by height of door 
            was: 
            scale="20 76 15"
            position="0 38 0"
            animation__showportal="property: scale; from: 20 76 15; to: 20 0 15; dur: 1900; startEvents: showportal; easing: linear "
            -->
              <a-box id="boxInFrontOfDoor"
                scale="20 100 15"
                position="0 50 0"
                animation__showportal="property: scale; from: 20 100 15; to: 20 50 15; dur: 1900; startEvents: showportal; easing: linear "
                hider-material
                show-door-ani-over-logic></a-box>
        
            <!-- Doorway door model (note: order is important as first listed is always drawn on top) 
            Door scale is actually set in 'scaleup-on-tap'. Reason: needs to start at 0, 0, 0 so not seen if user walks forward before spawning. Cannot be hidden otherwise texture is not loaded and causes hitch on show -->
            <a-entity
                id="doorEntity"
                position="0 0 0"
                scale="0 0 0"
                gltf-model="#doorModel"
                visible="true"
                save-orginal-model-material
                show-door-ani-on-tap
                scaleup-on-tap
                >
                    <a-entity
                    id="doorEntityL"
                    position="0 0 0"
                    scale="1 1 1"
                    gltf-model="#door_l"
                    visible="true"
                    animation__open="property: position; to: -1.75 0 0; dur: 1000; startEvents: open; easing: easeInOutQuad "
                    animation__close="property: position; to: 0 0 0; dur: 1000; startEvents: close; easing: easeInOutQuad "
                    transparent="false"
                     >
                          <a-entity
                        id="doorEntityLWindow"
                        position="0 0 0"
                        scale="1 1 1"
                        gltf-model="#door_l_window"
                        visible="true"
                        animation__open="property: position; to: -1.75 0 0; dur: 1000; startEvents: open; easing: easeInOutQuad "
                        animation__close="property: position; to: 0 0 0; dur: 1000; startEvents: close; easing: easeInOutQuad "
                        transparent="true"
                        material="alphaTest: 0.5"
                         ></a-entity>
                    </a-entity>
                    <a-entity
                    id="doorEntityR"
                    position="0 0 0"
                    scale="1 1 1"
                    gltf-model="#door_r"
                    visible="true"
                    animation__open="property: position; to: 1.75 0 0; dur: 1000; startEvents: open; easing: easeInOutQuad "
                    animation__close="property: position; to: 0 0 0; dur: 1000; startEvents: close; easing: easeInOutQuad "
                    transparent="false"
                    >
                       <a-entity
                        id="doorEntityRWindow"
                        position="0 0 0"
                        scale="1 1 1"
                        gltf-model="#door_r_window"
                        visible="true"
                        animation__open="property: position; to: 1.75 0 0; dur: 1000; startEvents: open; easing: easeInOutQuad "
                        animation__close="property: position; to: 0 0 0; dur: 1000; startEvents: close; easing: easeInOutQuad "
                        transparent="true"
                        material="alphaTest: 0.5"
                         ></a-entity>
                    </a-entity>
                    <!-- text sign --> 
                    <!-- standard font: 
                    font: https://cdn.aframe.io/fonts/mozillavr.fnt;" 
                    -->
                    <!-- custom font: 
                    shader: msdf; font:https://raw.githubusercontent.com/etiennepinchon/aframe-fonts/master/fonts/play/Play-Regular.json;"
                    from: https://github.com/etiennepinchon/aframe-fonts 
                    needs negate:true
                    WamS font:  MarkOT-msdf-coe9cgoai6.glb 
                    needs negate:false -->
                   <a-entity id="sceneLocationTextHolder" scenelocation_textholder_controller>
                        <a-entity
                            id="sceneLocationTextEntity"
                            text="align:center; value:Scene; negate:false; color:#FFFFFF; shader: msdf; font:./assets/MarkOT-msdf-rg8l0b460d.glb;"  
                            position="0 8.8 0.675"
                            scale="10 10 10"
                            scenelocation_text_setter
                            >
                        </a-entity>
                        <!-- text shadow attempt  
                        <a-entity
                            id="sceneLocationTextShadowEntity"
                            text="align: center; value: Location; color: black; shader: msdf; negate: false; font:./assets/MarkOT-msdf-rg8l0b460d.glb;" 
                            position="0 8.8 0.65"
                            scale="10.1 10.1 10.1"
                            scenelocation_text_setter
                            >
                        </a-entity> -->
                    </a-entity>
            </a-entity>
            
      
            <!-- Hider walls -->
            <a-entity id="hider-walls">
              <!-- above portal on front: wScale effected by width of door. yPosition & ySacle (set also in ani) effected by height of door  -->
              <a-box id="abovePortalHiderWall"
                scale="10 100 1"
                position="0 70 0"
                hider-material></a-box>
              <!-- front left: wScale effected by width of door-->
              <a-box
                scale="90 100 1"
                position="-50 50 0"
                hider-material></a-box>
              <!-- front right: wScale effected by width of door-->
              <a-box
                scale="90 100 1"
                position="50 50 0"
                hider-material></a-box>
              <!-- back -->
              <a-box
                scale="200 100 1"
                position="0 50 200"
                hider-material></a-box>
              <!-- top -->
              <a-box
                scale="200 1 201"
                position="0 100 100"
                hider-material></a-box>
              <!-- floor  -->
              <a-box
                scale="200 1 200"
                position="0 -0.5 100"
                hider-material></a-box>
              <!-- side left -->
              <a-box
                scale="1 100 205"
                position="-100 50 100"
                hider-material></a-box>
              <!-- side right -->
              <a-box
                scale="1 100 205"
                position="100 50 100"
                hider-material></a-box>
            </a-entity>
            
           
            <a-entity id="portal-contents"  >
              
              <!-- Balcony  -->
                <a-entity id="balcony"
                position="0 0 0"
                gltf-model="#balconyModel"
                scale="0 0 0"
                visible="true"
                scaleup-on-tap></a-entity>
            
            <!-- return side: xScale effected by width of door. yScale and yHeight effected by door height -->
            <a-entity id="portal-return-opening">
              <a-plane
                scale="11 25 1"
                rotation="180 0 0"
                position="0 10 0.5"
                hider-material></a-plane>
            </a-entity>    
            
           <!-- video sphere 360 video - do not change default rotation required for template lookup -->
           <a-videosphere id="videosphere" rotation="0 270 0" src="#video1"  videoeventhandler hide-after-load>
           </a-videosphere>    
      
            <!-- sky background for 360 photo - do not change default rotation required for template lookup -->
            <a-sky id="photosphere" rotation="0 270 0" src="#photo" photo-or-video hide-after-load></a-sky>
            
            <!-- ground outside if separate should go here --> 
   
            </a-entity>
        
            <!-- ground inside portal --> 
       
            <a-entity id="portal-world">
             
            </a-entity>
            
        
            
            <!-- Audio tracks -->
            
            <!-- narrator audio track -->
            <a-entity id="soundcue" sound="src: #audio; autoplay: false;"></a-entity>
            <a-entity id="doorSpawnSoundCue" sound="src: #doorSpawningAudio; autoplay: false; volume:4;"></a-entity>
            <a-entity id="doorOpenSoundCue" sound="src: #doorOpeningAudio; autoplay: false; volume:3;"></a-entity>
            
     </a-entity>
    
    <!-- visible ground reference for debugging
     <a-entity
        id="ground"
        class="cantap"
        geometry="primitive: box"
        material="color: #000000; transparent: true; opacity: 0.4"
        scale="1000 2 1000"
        position="0 -1 0"
        transparent=true
        >
      </a-entity>
     -->
    </a-scene>
    
   

  
  
  </html>
 