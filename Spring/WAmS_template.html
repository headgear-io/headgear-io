//Do not replace the templateContents line at the top and bottom!

var templateVersion = `0.9.4`;

var templateContents = `
<!DOCTYPE html>
  <html>
    <head>
      <!-- d16b784dcf125bafd1967e30c1918f909ea6c5c7 8d2927fdfbae9ea66e34caa4039a4c3f -->
      <meta charset="UTF-8">
  
      <title>AR Portal</title>
      <meta itemprop="name" content="AR Portal">
      <meta name="twitter:title" content="AR Portal">
      <meta name="og:title" content="AR Portal">
      <meta name="og:site_name" content="AR Portal">
      <meta name="image" content="https://cdn.8thwall.com/apps/cover/519zlgcbascq4pflqvdc4u12uh1z64gay7972yw7a77gv0c0n23f1dmh-preview">
      <meta itemprop="image" content="https://cdn.8thwall.com/apps/cover/519zlgcbascq4pflqvdc4u12uh1z64gay7972yw7a77gv0c0n23f1dmh-preview">
      <meta name="og:image" content="https://cdn.8thwall.com/apps/cover/519zlgcbascq4pflqvdc4u12uh1z64gay7972yw7a77gv0c0n23f1dmh-preview">
      <meta name="twitter:image:src" content="https://cdn.8thwall.com/apps/cover/519zlgcbascq4pflqvdc4u12uh1z64gay7972yw7a77gv0c0n23f1dmh-preview">
    
      <meta name="og:type" content="website">
      <meta name="twitter:card" content="summary">
		
		<script type="text/javascript">
		var trackingProvider = "None";
		switch (trackingProvider) {
			case "Tealium":
				var utag_data = {
					page_name : "AR Portal",
					page_section_path : "",
					page_section_1 : "",
					page_section_2 : "",
					page_platform : "" ,
					app_name : ""
				};
				(function(a,b,c,d){
					a='https://tags.tiqcdn.com/utag/axelspringer/welt/dev/utag.js';
					b=document;c='script';d=b.createElement(c);d.src=a;d.type='text/java'+c;d.async=true;
					a=b.getElementsByTagName(c)[0];a.parentNode.insertBefore(d,a);
				})();
				break;
		}
		</script>
		
      <script async src="https://apps.8thwall.com/xrweb?appKey=gLMESoMSiCXZ8Ye4C7ooAO5bRn59zFpGIxN07SWCegxZNtScEoTCxh8S9SsXTB8xOevOSn&s=1"></script>
     <script src="https://cdn.8thwall.com/web/aframe/8frame-0.9.2.min.js"></script>
      <script src="xrextras.js"></script>

      <!-- Copyright (c) 2019 8th Wall, Inc. -->
<!-- head.html is optional; elements will be added to your html head before app.js is loaded. -->



<!-- Other external scripts and meta tags can also be added. -->
<!-- tag for iOS icon homepage pinning -->
<link rel="apple-touch-icon" href="./assets/pagelogo.png">
 <link rel="icon" type="image/png" href="./assets/pagelogo.ico">
 
   <!-- meta tag for iOS video playback -->
   <meta name="apple-mobile-web-app-capable" content="yes">
   
   <!-- script for pushing debug logs onto screen! -->
   <script src="https://unpkg.com/aframe-log-component/dist/aframe-log-component.min.js"></script> 
   
   <script src="https://demos.jquerymobile.com/1.3.2/js/jquery.js"></script>
   <!-- currently not working: <script src="https://demos.jquerymobile.com/1.3.2/js/jquery.mobile-1.3.2.min.js"></script> -->
       
	   <style>

#tapScreenButton{
    
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  right: 0;
  height:100%;
  z-index:10;
}
#uiContainer{
    position: fixed;
    width:100%;
    height: 31vmin;
	bottom: -16vmin;
	z-index: 11;
	transition: all .3s ease-out;
	float:left;
	padding:0;
	margin:0;
	display: none;
}
#carrotContainer {
	width: 100%;
	height: 15vmin;
	position: relative;
	display: flex;
	align-items: center;
	justify-content: center;
	font-size: 15vmin;
	font-weight: bolder;
	color: white;
	opacity: 0.3;
	-webkit-text-stroke: 2px black;
	transition: all .3s ease-out;
	transform: rotate(0deg);
}
#shareButtonContainer {
  position: relative;
  width: 33%;
  float:left;
  padding:0;
  margin:0;
}
 #shareButton {
 position: relative;
  width: 15vmin;
  height: 15vmin;
  background-color: #003a5a;
  border-radius: 7.5vmin;
  transform: translateX(-50%);
  left: 50%;
  display: flex;
  align-items: center;
  justify-content: center;

  background-size: 50%;
  background-repeat: no-repeat;
  background-position: center center;
  pointer-events: auto;
  background-image: url('./assets/share_icon_white-evkawljf07.png');
  
}

#audioButtonContainer {
  position: relative;
  width: 33%;
  float:left;
  padding:0;
  margin:0;
  }
 #audioButton { 
 position: relative;
  width: 15vmin;
  height: 15vmin;
  background-color: #003a5a;
  border-radius: 7.5vmin;
  transform: translateX(-50%);
  left: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  background-size: 50%;
  background-repeat: no-repeat;
  background-position: center center;
  pointer-events: auto;
  background-image: url('./assets/speaking_icon_white-1wcsm890ik.png');
  
}

#infoButtonContainer {
  position: relative;
  width: 33%;
  float:left;
  padding:0;
  margin:0;
  }
 #infoButton {
 position: relative;
  width: 15vmin;
  height: 15vmin;
  background-color: #003a5a;
  border-radius: 7.5vmin;
  background-size: 50%;
  background-repeat: no-repeat;
  background-position: center center;
  pointer-events: auto;
  background-image: url('./assets/info_icon_white-b2f8k1eb95.png');
  transform: translateX(-50%);
  left: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
}

.ui-loader {
	display:none !important;
}
   </style>
      
    </head>
    <body>
	<script>
	// Copyright (c) 2020 Headgear
//
// app.js is the main entry point for your 8th Wall app. Code here will execute after head.html
// is loaded, and before body.html is loaded.
  

//*****Global Variables START**********************************      
    
    //whether to show debug on screen or not - should be false for clients & staging & production!
    var debugOnVar = false //to use log with the command: AFRAME.log('test')

    //text strings
    var INFO_TEXT1 = "Tippen Sie auf den Bildschirm, um die Tür zu platzieren"  //initial text shown
    var INFO_TEXT2 = "Gehe durch das Tor, um das Erlebnis zu starten." //text shown after placement
    var INFO_TEXT3 = "Einen Schritt zurück und es geht weiter, order tippen Sie zum Zurücksetzen auf den Bildschirm" //text shown when walking out of balcony
    var sceneLocationTextString = "Scene Location" //text to be shown above the door
    
    
    //experience setup ** THESE CAN BE CHANGED
    var hideDoorOnWalkthrough = false //true means door is hidden when user walks through - Needed for 2nd app demo!!
    var showBalcony = true   //true means balcony is shown
    var videoElsePhoto = true //true means video not photo
    var sceneLocationText = false //true means text will be shown above the door signifying the location
    var doorTriggerDistance = 7.5  //camera starts around a value of 9. Where a value of 0 = at the door
    var containsDoorAnimation = false //whether door animation exists
    var checkForBalcony = false //if true does a check to see if user has walked off balcony or not (out of bounds) - Currently not used!
    var BalconyWidth = 8 //distance to check if user is out of the balcony in the side (X) direction
    var BalconyDepth = 20  //distance to check if user is out of the balcony in the forward (depth) direction
    var infoURL = "https://headgear.io" //URL that info page opens
    var narrativeAudioExists = true // set via template default should be left true
    var infoLinkExists = true // set via template default should be left true
    var containsDoorSpawningSound = true // whether to play a door spawning sound - set via template default should be left true

    //global logic vars ** DO NOT CHANGE THESE
    var isInPortalSpace = false
    var wasOutside = true
    var withinPortalBounds = false
    var doorOpened = false
    var resetSceneTriggered = false //called for proper reset of the hide door when walking through scenerio
    var outofBoundsY = false  //if user is out of the balcony in the forward (depth) direction
    var outofBoundsX = false //if user is out of the balcony in the side (X) direction
    var doorVisible = false
    var materialOriginalDoor = new THREE.MeshStandardMaterial({})
    var materialOriginalDoorL = new THREE.MeshStandardMaterial({})
    var materialOriginalDoorR = new THREE.MeshStandardMaterial({})
    var materialOriginalBalcony = new THREE.MeshStandardMaterial({})
    var rotationy = 0
    var alreadyMoved = false
    var openMenu = false
    var playNarrativeAudio = true
    

//*****Global Variables END************************************


      // Checking if camera permissions have been excepted - if so fire tracking event
      AFRAME.registerComponent('camera-status-check', {
        init: function(){
          switch (trackingProvider) {
      			case "Tealium":
      				utag.link({ "event_name" : "ar", "event_action": "ar_initialized"});
      				break;
    		  }
          var handleCameraStatusChange = function handleCameraStatusChange(event) {
          //console.log('status change', event.detail.status);
      
        switch (event.detail.status) {
          case 'requesting':
            // Do something
            break;
      
          case 'hasStream':
            switch (trackingProvider) {
        			case "Tealium":
        				utag.link({ "event_name" : "ar", "event_action": "ar_loaded", "event_label": "consent to use camera given"});
        		}
            //console.log('camera has stream')
            break;
      
          case 'failed':
            //event.target.emit('realityerror');
            //break;
        }
      };
      let scene = this.el.sceneEl
      scene.addEventListener('camerastatuschange', handleCameraStatusChange)

        }
        })
        
       AFRAME.registerComponent('door-seen-by-camera', {
          init: function() {
           this.camera = 0;
            
            this.el.addEventListener("loaded", (e) => {
              setTimeout((e) => {
                //console.log(this.el.camera)
                console.log("camera about to be set")
                this.camera = document.getElementById('camera')
                this.camera = this.el.camera
                console.log("camera set")
              }, 500)
            })
          },
          tick: function() {
            if (this.camera !== 0) {
              var frustum = new THREE.Frustum();
              //console.log("frustum about to be set")
              frustum.setFromMatrix(new THREE.Matrix4().multiplyMatrices(this.el.camera.projectionMatrix, this.el.camera.matrixWorldInverse));
              //frustum.setFromMatrix(new THREE.Matrix4().multiplyMatrices(document.getElementById('camera').object3D.projectionMatrix, document.getElementById('camera').object3D.matrixWorldInverse));
              
              //console.log("frustum set")
              // Your 3d point to check
              //var pos = new THREE.Vector3(0, 0, 0);
              //this.door = document.getElementById('doorEntity')
              //this.door = this.el.door
              
              //var doorEntity = document.getElementById('doorEntity').el.object3D
              //console.log("this")
              //console.log(document.getElementById('doorEntity').el.projectionMatrix)
              //if (frustum.containsPoint(pos)) {
              //if (frustum.intersectsObject(document.getElementById('doorEntity').el.object3D)) {
                 
              //  console.log("hello")
              //}
            }
          }
      })

      // This component hides and shows certain elements as the camera moves as well as info text and balcony
      AFRAME.registerComponent('portal', {
        schema: {
          width: {default: 6},
          height: {default: 30}, //To do: make this dynamic
          depth: {default: 1}, //TO DO: check this value
        },
        init: function(){

          this.camera = document.getElementById('camera')
          this.contents = document.getElementById('portal-contents')
          this.walls = document.getElementById('hider-walls')
          this.portalWall = document.getElementById('portal-return-opening')
          this.portalWorld = document.getElementById('portal-world')
          
          //get sceneHolder distance
          this.sceneholder = document.getElementById('scene-holder')
          depthOffset = this.sceneholder.getAttribute('position').z
          newX = this.sceneholder.getAttribute('position').x
          newY = this.sceneholder.getAttribute('position').y
          newZ = this.sceneholder.getAttribute('position').z
          intialCameraPositionX = this.camera.getAttribute('position').x
          intialCameraPositionY = this.camera.getAttribute('position').y
          intialCameraPositionZ = this.camera.getAttribute('position').z 

          tapScreen = document.getElementById('tapScreenButton')
          
          //XR8.XrController.configure({disableWorldTracking: false}) //does not work with 8th wall currently
          
        },
        tick: function() {
          const position = this.camera.object3D.position
          depthOffset = this.sceneholder.getAttribute('position').z
          var isOutside = position.z  > ((this.data.depth / 2) + depthOffset)
          //var rotationy = this.camera.getAttribute('rotation').y + 180
          
          //within width of the door:     //old: const withinPortalBounds = position.y < this.data.height && Math.abs(position.x) < this.data.width / 2
          const withinPortalBounds = (position.x < (this.sceneholder.getAttribute('position').x + (this.data.width / 2)) && position.x > (this.sceneholder.getAttribute('position').x) - (this.data.width / 2) ) 
          //console.log(withinPortalBounds)

        //check if reset scene has been triggered
          if (resetSceneTriggered) {
               
               alreadyMoved = false
               outofBoundsY = false
               outofBoundsX = false
               isInPortalSpace = false
               isOutside = true
               if (hideDoorOnWalkthrough) {
                  //through door show  door
                  document.getElementById('doorEntity').setAttribute('visible', 'true')
                  document.getElementById('balcony').setAttribute('visible', 'true')
              }
              tapScreen.style.backgroundColor = 'rgba(0, 0, 0, 0)';
              resetSceneTriggered = false
          }
          
          
        // check if user has walked into portal
          if (!isInPortalSpace && !isOutside && withinPortalBounds && doorVisible) {
                isInPortalSpace = true
                portalCameraPositionX = this.camera.getAttribute('position').x
                portalCameraPositionY = this.camera.getAttribute('position').y
                portalCameraPositionZ = this.camera.getAttribute('position').z
                
                //AFRAME.log(this.camera.object3D.rotation)
                rotationy = this.camera.getAttribute('rotation').y + 180
                if ((rotationy - 180) < 0) { 
                    rotationy = (rotationy - 180) + 360 
                } else {
                  rotationy = rotationy - 180
                }
                AFRAME.log('Into portal: opposite rotation = ' + rotationy)
                //getWorldPosition(position); .getAttribute('rotation')
                
                //hide stuff:
                //through door hide info text
                document.getElementById('infoText').object3D.visible = false
                //through door hide arrow
                document.getElementById('arrow-image-holder').setAttribute('visible', 'false')
                
              if (hideDoorOnWalkthrough) {
                //through door hide door
                document.getElementById('doorEntity').setAttribute('visible', 'false')
                document.getElementById('balcony').setAttribute('visible', 'false')
                this.portalWall.object3D.visible = false
              }
              
              //play narrative sound
              if (playNarrativeAudio && narrativeAudioExists) {
                var entity = document.querySelector('#soundcue')
                entity.components.sound.playSound();
              }  
              switch (trackingProvider) {
      				  case "Tealium":
        					utag.link({ "event_name" : "ar", "event_action": "user_walked_through_portal"});
        				  break;
      			  }
              
              //test to disable world tracking
              //XR8.stop()
              //XR8.XrController.configure({disableWorldTracking: false})
          
        //else check if user has walked out of portal
          } else if (isInPortalSpace && isOutside) {
              AFRAME.log('walked out of portal')
              isInPortalSpace = false
              isOutside = true
              //reset narrative audio
              document.querySelector('#soundcue').components.sound.stopSound()
              //hide door when walking out
              document.getElementById('boxInFrontOfDoor').setAttribute('visible', 'true')
              document.getElementById('boxInFrontOfDoor').setAttribute('scale', {x:20, y:76, z:15})
              
              document.getElementById('doorEntity').setAttribute('visible', 'false')
              document.getElementById('balcony').setAttribute('visible', 'false')
              document.getElementById('videosphere').setAttribute('visible', 'false')
              document.getElementById('photosphere').setAttribute('visible', 'false')
              //set info text1
              document.getElementById('infoText').setAttribute('text', 'value: ' + INFO_TEXT1)
              document.getElementById('infoText').object3D.visible = true
              doorVisible = false
          }
          
        //Mode1: reappear door check if opposite rotation and user in portal
             if ((Math.abs(this.camera.getAttribute('rotation').y + 180 - rotationy) < 60 ) && isInPortalSpace && !alreadyMoved && hideDoorOnWalkthrough){
                alreadyMoved = true
                AFRAME.log('reshow')
                //AFRAME.log('camera position = ' + this.camera.getAttribute('position').x + ', ' + (this.camera.getAttribute('position').y - intialCameraPositionY) + ', z - 10' + (this.camera.getAttribute('position').z + 10))
                //set new Y
                if ((this.camera.getAttribute('position').y - intialCameraPositionY) < -1) {
                   newY = -1
                } else {
                  newY = this.camera.getAttribute('position').y - intialCameraPositionY
                }
                //set new X
                if ((Math.abs(this.camera.getAttribute('rotation').y + 180 - rotationy) > 30 )) {
                  newX = this.camera.getAttribute('position').x - 3.5
                } else if ((Math.abs(this.camera.getAttribute('rotation').y + 180 - rotationy) > 30 )) {
                  newX = this.camera.getAttribute('position').x + 3.5
                }
                lookAtX = this.camera.getAttribute('position').x
                // set new Z
                newZ = this.camera.getAttribute('position').z + 10
                
                this.sceneholder.setAttribute('position', {x: newX, y: newY, z: newZ});
                //this.sceneholder.object3D.lookAt(lookAtX, newY, newZ)
                //this.sceneholder.setAttribute('rotation', {x: (this.camera.getAttribute('rotation').x - 90), y: this.camera.getAttribute('rotation').y, z: this.camera.getAttribute('rotation').z});
                
                document.getElementById('doorEntity').setAttribute('visible', 'true')
                document.getElementById('balcony').setAttribute('visible', 'true')
                this.portalWall.object3D.visible = true
  
            } 
            else if (((Math.abs(this.camera.getAttribute('rotation').y + 180 - rotationy) > 120 ) && isInPortalSpace && alreadyMoved) || ((Math.abs(this.camera.getAttribute('rotation').y + 180 - rotationy) > 60 ) && !isInPortalSpace && alreadyMoved)) { //hide door again 2nd case for catching edge case of out of portal bug
                alreadyMoved = false
                AFRAME.log('hide')
                document.getElementById('doorEntity').setAttribute('visible', 'false')
                document.getElementById('balcony').setAttribute('visible', 'false')
                this.portalWall.object3D.visible = false
            }
          
        //Mode2: stick portal to camera if inside portal
            if (isInPortalSpace && !hideDoorOnWalkthrough){
                //AFRAME.log(Math.abs(this.camera.getAttribute('position').z - portalCameraPositionZ))
                
                //set x for sceneHolder
                if ((this.camera.getAttribute('position').x - portalCameraPositionX) > BalconyWidth) {
                    newX = this.camera.getAttribute('position').x - BalconyWidth
                } else if ((this.camera.getAttribute('position').x - portalCameraPositionX) < -BalconyWidth) {
                    newX = this.camera.getAttribute('position').x + BalconyWidth
                    if (!outofBoundsX) {
                      AFRAME.log('out of balcony X');
                      outofBoundsX = true
                      //change text / reshow
                      document.getElementById('infoText').setAttribute('text', 'value: ' + INFO_TEXT3)
                      document.getElementById('infoText').object3D.visible = true
                      tapScreen.style.backgroundColor = 'rgba(0, 0, 0, 0.6)'
                  }
                } else {
                    newX = this.sceneholder.getAttribute('position').x
                    if (outofBoundsX) {
                      AFRAME.log('in balcony again X');
                      outofBoundsX = false
                      //hide out of bounds text
                      document.getElementById('infoText').object3D.visible = false
                      tapScreen.style.backgroundColor = 'rgba(0, 0, 0, 0)'
                    }
                }
                //Check for correct Z (distance from camera)
                if (this.camera.getAttribute('position').z - portalCameraPositionZ < - BalconyDepth) {
                  //AFRAME.log('stuck on z: ' + (this.camera.getAttribute('position').z - portalCameraPositionZ))
                  newZ = this.camera.getAttribute('position').z + BalconyDepth
                  if (!outofBoundsY) {
                      AFRAME.log('out of balcony Y');
                      outofBoundsY = true
                      //change text / reshow
                      document.getElementById('infoText').setAttribute('text', 'value: ' + INFO_TEXT3)
                      document.getElementById('infoText').object3D.visible = true
                      tapScreen.style.backgroundColor = 'rgba(0, 0, 0, 0.6)'
                  }
                } else {
                  newZ = this.sceneholder.getAttribute('position').z
                  //this.sceneholder.setAttribute('position', {x: this.camera.getAttribute('position').x, y: -1, z: this.sceneholder.getAttribute('position').z})  
                  if (outofBoundsY) {
                      AFRAME.log('in balcony again Y');
                      outofBoundsY = false
                      //hide out of bounds text
                      document.getElementById('infoText').object3D.visible = false
                      tapScreen.style.backgroundColor = 'rgba(0, 0, 0, 0)'
                  }
                }
                
                //check for Y
                if ((this.camera.getAttribute('position').y - intialCameraPositionY) < -1) { // this.sceneholder.getAttribute('position').y
                    AFRAME.log('Y less than -1: ' + (this.camera.getAttribute('position').y))
                    newY = -1
                //    AFRAME.log('Y great than 10: ' + (this.camera.getAttribute('position').y))
                //    newY = this.camera.getAttribute('position').y - 12his.camera.getAttribute('position').y - 10, z: this.sceneholder.getAttribute('position').z})  
                } else {
                    //AFRAME.log('Y ' + (this.camera.getAttribute('position').y))
                   newY = this.camera.getAttribute('position').y - intialCameraPositionY  
                } 
                //set resulting position
                this.sceneholder.setAttribute('position', {x: newX, y: newY, z: newZ})  
  
            }
          
        //door animation check
          if ((position.z < doorTriggerDistance) && !doorOpened && containsDoorAnimation && doorVisible) {
              doorOpened = true
              //console.log('door opened')
              document.querySelector('#doorEntityL').emit('open')
              document.querySelector('#doorEntityR').emit('open')
              document.querySelector('#doorOpenSoundCue').components.sound.stopSound()
              document.querySelector('#doorOpenSoundCue').components.sound.playSound()
          } else if ((position.z > doorTriggerDistance) && doorOpened && containsDoorAnimation && doorVisible) {
              doorOpened = false
              //console.log('door closed')
              document.querySelector('#doorEntityL').emit('close')
              document.querySelector('#doorEntityR').emit('close')
              document.querySelector('#doorOpenSoundCue').components.sound.stopSound()
              document.querySelector('#doorOpenSoundCue').components.sound.playSound()
          }
          //end door animation check
          
          //console.log('isInPortalSpace = ' + isInPortalSpace + ', isOutside = ' + isOutside)
        //set visibilities of portal components
          this.contents.object3D.visible = isInPortalSpace || isOutside
          this.walls.object3D.visible = !isInPortalSpace && isOutside
          if (!hideDoorOnWalkthrough) { this.portalWall.object3D.visible = isInPortalSpace && !isOutside }
          this.portalWorld.object3D.visible = isInPortalSpace

          wasOutside = isOutside
          
          
        }
      })



 //This component plays the video on screen tap if it doesn't autoplay and resets the tracking on screentap
    AFRAME.registerComponent('touchscreen-handler', {
      init: function() {
           
            const uiContainer = document.getElementById('uiContainer')
            const closeButton = document.getElementById('placeholderButton')
            const tapScreen = document.getElementById('tapScreenButton')
            const sceneHolder = document.getElementById('scene-holder')
            const camera = document.getElementById('camera')

            //tap screen listener for non-specific components:
            tapScreen.addEventListener('click', () => {
                  console.log('tapScreen pressed')
                  
                  if (!isInPortalSpace || outofBoundsY || outofBoundsX) {
                    // recenter scene, camera and sceneHolder
                    let scene = this.el.sceneEl
                    //scene.emit('recenter')
                    scene.emit('recenter', {
                        origin: {x: 0, y: 12, z: 8}
                     })
                    //scene.emit('recenter', {
                    //    origin: {x: 0, y: 8, z: 8},
                    //    facing: {w: 0, x:0, y:0, z:0}
                    // })
                    camera.setAttribute('position', {x: 0, y: 12, z: 8})
                    sceneHolder.setAttribute('position', {x: 0, y: -1, z: -10})
                    AFRAME.log('scene-holder postion: x:' + sceneHolder.getAttribute('position').x + ', y:' + sceneHolder.getAttribute('position').y + ',z:' + sceneHolder.getAttribute('position').z)
                    //this.sceneholder.setAttribute('position', {x: this.camera.getAttribute('position').x, y: -1, z: this.camera.getAttribute('position').z - 10})
                    resetSceneTriggered = true  //reseting some other vars in the portal ontick
                    
                    //reset narrative audio
                    var soundEntity = document.querySelector('#soundcue')
                    soundEntity.components.sound.stopSound();
                    
                    //check if video is playing yet
                    if (videoElsePhoto){
                      //play video
                      var video = document.querySelector('#videosphere').components.material.material.map.image;
                      if (!video) { return; }
                      video.play();
                     }
                  }    
            })  //end tap screen eventhandler
          
      }
    });

   //This handles starting the show door animation on a screen tap
    AFRAME.registerComponent('show-door-ani-on-tap', {
      init: function() {
         const tapScreen = document.getElementById('tapScreenButton')
         //tap screen listener:
            tapScreen.addEventListener('click', () => {
                   
                  //Door & Balcony: material change
                  if (!isInPortalSpace || outofBoundsY || outofBoundsX) { 
                    
                        //set wirefirame materials door:
                          let el = document.getElementById('doorEntity');
                          let mesh = el.getObject3D('mesh'); 
                          if (!mesh){return;}
                          //console.log(mesh);
                          mesh.traverse(function(node){
                             if (node.isMesh){  
                               let materialOriginalDoor = node.material
                               node.material = new THREE.MeshStandardMaterial({
                                  color : 0x00ff00,
                                 wireframe : true,
                                 emissive:  0x00ff00,
                                 emissiveIntensity: 10,
                                 opacity : 1
                               });
                             }
                          });
                          //set wireframe materials balcony:
                          if (showBalcony) {
                              let el = document.getElementById('balcony');
                                let mesh = el.getObject3D('mesh'); 
                                if (!mesh){return;}
                                //console.log(mesh);
                                mesh.traverse(function(node){
                                   if (node.isMesh){  
                                     let materialOriginalBalcony = node.material
                                     node.material = new THREE.MeshStandardMaterial({
                                        color : 0x00ff00,
                                       wireframe : true,
                                       emissive:  0x00ff00,
                                       emissiveIntensity: 10,
                                       opacity : 1
                                     });
                                   }
                                });        
                          }
                          if (containsDoorAnimation) {
                                let el_L = document.getElementById('doorEntityL');
                                let mesh_L = el_L.getObject3D('mesh'); 
                                if (!mesh_L){return;}
                                //console.log(mesh);
                                mesh_L.traverse(function(node){
                                   if (node.isMesh){  
                                      let materialOriginalDoorL = node.material
                                      node.material = new THREE.MeshStandardMaterial({
                                        color : 0x00ff00,
                                       wireframe : true,
                                       emissive:  0x00ff00,
                                       emissiveIntensity: 10,
                                       opacity : 1
                                     });
                                   }
                                });  
                                let el_R = document.getElementById('doorEntityR');
                                let mesh_R = el_R.getObject3D('mesh'); 
                                if (!mesh_R){return;}
                                //console.log(mesh);
                                mesh_R.traverse(function(node){
                                   if (node.isMesh){  
                                      let materialOriginalDoorR = node.material
                                      node.material = new THREE.MeshStandardMaterial({
                                        color : 0x00ff00,
                                       wireframe : true,
                                       emissive:  0x00ff00,
                                       emissiveIntensity: 10,
                                       opacity : 1
                                     });
                                   }
                                });   
                          }
                          
                  
                        //hide info text and arrow while door is animating
                        document.getElementById('infoText').object3D.visible = false
                        document.getElementById('arrow-image-holder').setAttribute('visible', 'false')
                        
                        //start animation of box hider
                        document.getElementById('boxInFrontOfDoor').emit('showportal')
                        document.getElementById('boxInFrontOfDoor').setAttribute('visible', 'true')
                        document.getElementById('doorEntity').setAttribute('visible', 'true')
                        if (showBalcony) { document.getElementById('balcony').setAttribute('visible', 'true') }
                        if (containsDoorSpawningSound) { 
                          document.querySelector('#doorSpawnSoundCue').components.sound.stopSound()
                          document.querySelector('#doorSpawnSoundCue').components.sound.playSound() 
                        }
                  }
            })
      }
    });


 //This handles the logic for when the show door animation is complete
    AFRAME.registerComponent('show-door-ani-over-logic', {
      init: function() {
      
          document.getElementById('boxInFrontOfDoor').addEventListener('animationcomplete', (e) => {
          //console.log(e.detail.name);
                                    
          if (e.detail.name == 'animation__showportal') {
                 //console.log('show portal done')
                 document.getElementById('boxInFrontOfDoor').setAttribute('visible', 'false')
                 
                  let eldoor = document.getElementById('doorEntity');
                  let mesh = eldoor.getObject3D('mesh'); 
                  if (!mesh){return;}
                  mesh.traverse(function(node){
                    if (node.isMesh){  
                      node.material = materialOriginalDoor
                    }
                  });
            if (showBalcony) {
                  let elbalcony = document.getElementById('balcony');
                  let mesh = elbalcony.getObject3D('mesh'); 
                  if (!mesh){return;}
                  mesh.traverse(function(node){
                     if (node.isMesh){  
                       node.material = materialOriginalBalcony
                     }
                  });
                }
            if (containsDoorAnimation) {
              let el_L = document.getElementById('doorEntityL');
                  let mesh_L = el_L.getObject3D('mesh'); 
                  if (!mesh_L){return;}
                  mesh_L.traverse(function(node){
                     if (node.isMesh){  
                       node.material = materialOriginalDoorL
                       console.log("set l door material")
                     }
                  });
                  let el_R = document.getElementById('doorEntityR');
                  let mesh_R = el_R.getObject3D('mesh'); 
                  if (!mesh_R){return;}
                  mesh_R.traverse(function(node){
                     if (node.isMesh){  
                       node.material = materialOriginalDoorR
                     }
                  });
            }
            doorVisible = true
            
            //change text / reshow
            document.getElementById('infoText').setAttribute('text', 'value: ' + INFO_TEXT2)
            document.getElementById('infoText').object3D.visible = true
            //show arrow
            document.getElementById('arrow-image-holder').setAttribute('visible', 'true')
            switch (trackingProvider) {
      				case "Tealium":
      					utag.link({ "event_name" : "ar", "event_action": "user_placed_portal"});     
      				break;
      			}    
          }
        }) 
      }
    })

 
      //This hides video/photo sphere inside the initial hider box in case user walks in there before spawning door
    AFRAME.registerComponent('hide-after-load', {         
          init: function () {
             // After entity has loaded scale down to make 'invisible'
            this.el.addEventListener('loaded', (e) => {

                this.el.object3D.visible = false;
            })
          }
     })
 
    //This shows video/photo sphere on tap
    AFRAME.registerComponent('show-on-tap', {         
          init: function () {
            const tapScreen = document.getElementById('tapScreenButton')
            //tap screen listener:
            tapScreen.addEventListener('click', () => {
                if (this.el == document.getElementById('videosphere')) { if (videoElsePhoto) {if (!this.el.object3D.visible) {this.el.object3D.visible = true;}}}
                else if (this.el == document.getElementById('photosphere')) { if (!videoElsePhoto) {if (!this.el.object3D.visible) {this.el.object3D.visible = true;}}}
            })
          }
     })

    //This shows models on tap
    AFRAME.registerComponent('scaleup-on-tap', {         
          init: function () {
            const tapScreen = document.getElementById('tapScreenButton')
            //tap screen listener:
            tapScreen.addEventListener('click', () => {
                if (!isInPortalSpace || outofBoundsY || outofBoundsX) {
                  this.el.object3D.scale.set(2.3, 2.3, 2.3); //this causes a flash if use walks through door and spawns from other side - could be moved for this edge case
                }
            })
          }
     })  
     

    //This saves the original material of the door and balcony models
    AFRAME.registerComponent('save-orginal-model-material', {         
          init: function () {
             // After gltf model has loaded,save it's default material
            let eldoor = document.getElementById('doorEntity');
            eldoor.addEventListener('model-loaded', function(ev){
              let mesh = eldoor.getObject3D('mesh'); 
              if (!mesh){return;}
              mesh.traverse(function(node){
                 if (node.isMesh){  
                   materialOriginalDoor = node.material
                   
                 }
              });
            });
            if (showBalcony) {
                elbalcony = document.getElementById('balcony');
                elbalcony.addEventListener('model-loaded', function(ev){
                  let mesh = elbalcony.getObject3D('mesh'); 
                  if (!mesh){return;}
                  mesh.traverse(function(node){
                     if (node.isMesh){  
                       materialOriginalBalcony = node.material
                       
                     }
                  });
                });
            }
          }
        });


        

      // This component gives the invisible hider walls the property they need
      AFRAME.registerComponent('hider-material', {
        init: function() {
          const mesh = this.el.getObject3D('mesh')
          mesh.material.colorWrite = false
        },
      })

      // To set the initial info text
      AFRAME.registerComponent('set-initial-info-text', {
        init: function() {
          this.el.setAttribute('text', 'value: ' + INFO_TEXT1)
        },
      })
      
      
    
    
      //To hide or show  the sceneLocationText above door
      AFRAME.registerComponent('scenelocation_textholder_controller', {
        init: function() {
          
          if (sceneLocationText) {
            document.getElementById('sceneLocationTextHolder').setAttribute('visible', 'true')
          } else {
            document.getElementById('sceneLocationTextHolder').setAttribute('visible', 'false')
          }
        },
         
      });
      
      //to set the text of the scenelocationText entitys
        AFRAME.registerComponent('scenelocation_text_setter', {
        init: function() {
            if (sceneLocationText) {
            this.el.setAttribute('text', 'align: center; value: ' + sceneLocationTextString + '; color: white; font: https://cdn.aframe.io/fonts/mozillavr.fnt;')
          }
        },
         
      })
    
    //to show either photo or video sphere
     AFRAME.registerComponent('photo-or-video', {
        init: function() {
          if (videoElsePhoto) {
            document.querySelector("#photosphere").setAttribute('visible', 'false')

          } else {
            document.querySelector("#videosphere").setAttribute('visible', 'false')
          }
          
        },
      })
    
 
    
              
    
   

    
 // To handle the looping arrow-animation
      AFRAME.registerComponent('arrow-ani-setup', {
        init: function() {
          var arrow1 = document.querySelector('#arrow1')
          //var arrow2 = document.querySelector('#arrow2')
          //var arrow3 = document.querySelector('#arrow3')
          this.el.addEventListener('loaded', (e) => {
              //console.log('loaded')
              arrow1.emit('moveup');
              //setTimeout(function(){ arrow2.emit('moveup'); }, 400);
              //setTimeout(function(){ arrow3.emit('moveup'); }, 800);
          })
        },
      })
       
       AFRAME.registerComponent('arrow-ani', {
        init: function() {
          this.el.addEventListener('animationcomplete', (e) => {
            //console.log(e.detail.name);
            if (e.detail.name == 'animation__moveup') {
                this.el.emit('moveup');
                this.el.emit('fadein');
            } 
            if (e.detail.name == 'animation__fadein') {
                  //console.log('fadein done')
                    this.el.emit('fadeout');
                } 
            if (e.detail.name == 'animation__fadeout') {
                  //console.log('fadeout done')
                    this.el.emit('fadein');
                }
          })

      
        },
      })



      // For showing debug logs on screen
      AFRAME.registerComponent('debugon', {
        init: function() {
          this.el.setAttribute('visible', debugOnVar)
        },
      })
      

    //Dynamic Lighting - partially used
      AFRAME.registerComponent('xr-light', {
        schema: {
          min: {default: 0},
          max: {default: 20}
        },
        init: function() {
          const startListen = () => {
            window.XR.XrController.configure({enableLighting: true})
            window.XR.addCameraPipelineModule({
              name: 'xr-light',
              onUpdate: ({processCpuResult}) => {
                if (processCpuResult.reality && processCpuResult.reality.lighting && processCpuResult.reality.lighting.exposure) {
                  this.intensity = 1 + processCpuResult.reality.lighting.exposure
                }
              }
            })
          }

          this.intensity = 1

          window.XR ? startListen() : window.addEventListener('xrloaded', startListen)

          },
        tick: function() {
          let headlights = this.el.sceneEl.querySelectorAll('a-cone')
          var tempIntensity = Math.max(this.data.min, Math.min((this.system.intensity * 10), this.data.max))
          this.el.setAttribute('light', 'intensity: ' + tempIntensity)
          //console.log(tempIntensity)
         
                    
          }
        })




  //Video event handler not used yet
    AFRAME.registerComponent('videoeventhandler', {
      init: function() {
          if (videoElsePhoto){
            var video = this.el.components.material.material.map.image;
           
           console.log('video = ' + video)
             //video event testing
                  video.addEventListener('waiting', (event) => {
              console.log('Video is waiting for more data.');
            });
            
                  video.addEventListener('stalled', (event) => {
              console.log('Video is stalled for more data.');
            });
            
            video.addEventListener('playing', (event) => {
              console.log('Video is no longer paused');
            });
            
            video.addEventListener('canplay', (event) => {
              console.log('Video can start, but not sure it will play through.' + video.readyState);
            });
            video.addEventListener('progress', (event) => {
              console.log('resource loading buffered = ' + Math.round(video.buffered.end(0)) + ' of ' + Math.round(video.seekable.end(0)) + ' secs');
            });
            video.addEventListener('canplaythrough', (event) => {
              console.log('I think I can play through the entire ' + 'video without ever having to stop to buffer.');
            });
            video.addEventListener('loadeddata', (event) => {
              console.log('Yay! The readyState just increased to  ' + 'HAVE_CURRENT_DATA or greater for the first time.');
            });
          }
      },
       
    });


 
  //Component to handle Menu interactions and buttons
    AFRAME.registerComponent('menu-interactions', {
      init: function() { 

      //show menu
           $('#uiContainer').css('display', 'block');
           if (!narrativeAudioExists) { $('#audioButton').css('opacity', '0.0'); }
           if (!infoLinkExists) { $('#infoButton').css('opacity', '0.0'); }
           
           //script for swipe up and down
            var supportTouch = $.support.touch,
                        scrollEvent = "touchmove scroll",
                        touchStartEvent = supportTouch ? "touchstart" : "mousedown",
                        touchStopEvent = supportTouch ? "touchend" : "mouseup",
                        touchMoveEvent = supportTouch ? "touchmove" : "mousemove";
                $.event.special.swipeupdown = {
                    setup: function() {
                        var thisObject = this;
                        var $this = $(thisObject);
                        $this.bind(touchStartEvent, function(event) {
                            var data = event.originalEvent.touches ?
                                    event.originalEvent.touches[ 0 ] :
                                    event,
                                    start = {
                                        time: (new Date).getTime(),
                                        coords: [ data.pageX, data.pageY ],
                                        origin: $(event.target)
                                    },
                                    stop;
            
                            function moveHandler(event) {
                                if (!start) {
                                    return;
                                }
                                var data = event.originalEvent.touches ?
                                        event.originalEvent.touches[ 0 ] :
                                        event;
                                stop = {
                                    time: (new Date).getTime(),
                                    coords: [ data.pageX, data.pageY ]
                                };
            
                                // prevent scrolling
                                if (Math.abs(start.coords[1] - stop.coords[1]) > 10) {
                                    event.preventDefault();
                                }
                            }
                            $this
                                    .bind(touchMoveEvent, moveHandler)
                                    .one(touchStopEvent, function(event) {
                                $this.unbind(touchMoveEvent, moveHandler);
                                if (start && stop) {
                                    if (stop.time - start.time < 1000 &&
                                            Math.abs(start.coords[1] - stop.coords[1]) > 30 &&
                                            Math.abs(start.coords[0] - stop.coords[0]) < 75) {
                                        start.origin
                                                .trigger("swipeupdown")
                                                .trigger(start.coords[1] > stop.coords[1] ? "swipeup" : "swipedown");
                                    }
                                }
                                start = stop = undefined;
                            });
                        });
                    }
                };
                $.each({
                    swipedown: "swipeupdown",
                    swipeup: "swipeupdown"
                }, function(event, sourceEvent){
                    $.event.special[event] = {
                        setup: function(){
                            $(this).bind(sourceEvent, $.noop);
                        }
                    };
                });
              //end script for swipe up and down
 
             $('#uiContainer').on('swipedown',function(){
            	console.log("swipedown..");
            	slidingMenu();
            });
            $('#uiContainer').on('swipeup',function(){
            	console.log("swipeup..");
            	slidingMenu();
            } );
            
            $('#carrotContainer').on('click',function(){
            	console.log("open..");
            	slidingMenu();
            });
            //for showing and hiding menu
            function slidingMenu() {
            	if (openMenu) {
            		console.log('hiding');
            		openMenu = false;
            		$('#uiContainer').css('bottom', '-16vmin');
            		$('#carrotContainer').css('transform', 'rotate(0deg)');
            	} else {
            		console.log('showing');
            		openMenu = true;
            		$('#uiContainer').css('bottom', '0vmin');
            		$('#carrotContainer').css('transform', 'rotate(-180deg)');
            	}
            }
            
            //share data for share button
            const shareData = {
              title: 'AR Portal',
              text: '',
              url: window.location.href ,
            }
            //share button
            $('#shareButton').on('click',function(){
            	try {
            		navigator.share(shareData)
            	  } catch(err) {
            		console.log('Share Error: ' + err);
            	  }
            });
            
            //info button - opens in same tab since leaving breaks gyroscope when returning on android
             if (infoLinkExists) {
                $('#infoButton').on('click',function(){
            	      window.open(infoURL, "_self"); 
            	  });
             }
             
             //audio button for toggling narrative audio on/off
             if (narrativeAudioExists) {
                 $('#audioButton').on('click',function(){
                		playNarrativeAudio = !playNarrativeAudio
                	  if (!playNarrativeAudio) {
                	    //stop narrative audio
                      document.querySelector('#soundcue').components.sound.stopSound()
                      $('#audioButton').css("background-image", "url('./assets/speaking_off_icon_white-ociio8cdic.png')");
                	  } else {
                	    $('#audioButton').css("background-image", "url('./assets/speaking_icon_white-1wcsm890ik.png')");
                	  }
                	  if (isInPortalSpace && playNarrativeAudio) {
                	    document.querySelector('#soundcue').components.sound.playSound() //turn sound back on
                	  }
                });
            }
            
      },
       
    });
	</script>
<!-- Copyright (c) 2020 Headgear -->

<!-- body.html ; elements will be added to your html body after app.js is loaded. -->

 <!-- These HTML elements are used to show an UI laid over the scene -->
      <div id="tapScreenButton"></div>
      <div id="uiContainer">
        	<div id="carrotContainer">^</div>
        	<div id="shareButtonContainer">
        		<div id="shareButton"></div>
        	</div>  
        	<div id="audioButtonContainer">
        		<div id="audioButton"></div>
        	</div>  
        	<div id="infoButtonContainer">
        		<div id="infoButton"></div>
        	</div>  
      </div>

<!-- aframe scene components -->

 <a-scene id="scene"
 light="defaultLightsEnabled: false"
      xrweb
      camera-status-check
      touchscreen-handler
      menu-interactions
      aframe-log-component
      photo-or-video
      xrextras-almost-there
      xrextras-loading
      xrextras-runtime-error
      door-seen-by-camera> <!-- stats -->

      <!-- We can define assets here to be loaded when A-Frame initializes -->
      <a-assets>
       
       <!-- <a-asset-item id="doorModel" src="./assets/door230cm.glb"></a-asset-item>  -->
        <a-asset-item id="doorModel" src="./assets/door_model.glb"></a-asset-item>
        <a-asset-item id="balconyModel" src="./assets/balcony_model.glb"></a-asset-item>
        <a-asset-item id="door_l" src=""></a-asset-item>
        <a-asset-item id="door_r" src=""></a-asset-item>

        <img id="arrowhead-image" src="./assets/arrowhead.png">
        
          <!-- asset for 360 photo and or video poster -->
        <img id="photo" src="./assets/video_thumbnail.jpg">

         <!-- Audio Assets -->
         <!-- asset for narrator -->
        <audio id="audio" src="./assets/narrative.mp3" preload="auto"></audio>
         <!-- asset for door spawning sound -->
        <audio id="doorSpawningAudio" src="./assets/door_spawning_sound.mp3" preload="auto"></audio>
         <!-- asset for door opening sound -->
        <audio id="doorOpeningAudio" src="./assets/door_opening_sound.mp3" preload="auto"></audio>
        
      </a-assets>
      <!-- Different timeout mentioned here in case we wish to start the video streaming sooner -->
      <a-assets timeout="3000">
        
        <video id="video1" src="./assets/360_video.mp4"
          loop crossorigin="anonymous" preload="auto" playsinline webkit-playsinline></video>
      
      </a-assets>

       <a-camera
        id="camera"
        position="0 12 8"> <!-- changing the depth/height (y) and distance (z) of the camera results in a rescale of the door -->
           
          <a-entity id="arrow-image-holder" visible="false" arrow-ani-setup>
             <a-image id="arrow1" position="0 0.025 -1" scale="0.1 0.2 0.1" src="#arrowhead-image" transparent="true" shader="flat" opacity="0.0" material="alphaTest: 0.5"
                          animation__moveup="property: position; from: 0 0.025 -1; to: 0 0.4 -1.5; dur: 2000; startEvents: moveup; easing: easeInOutQuad "
                          animation__fadein="property: material.opacity; from: 0.0; to: 1.0; startEvents: animtioncomplete__moveup; dur: 1000; startEvents: fadein; easing: easeInOutQuad"
                           animation__fadeout="property: material.opacity; from: 1.0; to: 0.0; dur: 1000; startEvents: animationcomplete__fadein; startEvents: fadeout; easing: easeInOutQuad "
                          
                           arrow-ani>
              </a-image>  
              <!-- for multiple arrows:
              <a-image id="arrow2" position="0 0.025 -1" scale="0.1 0.1 0.1" src="#arrowhead-image" transparent="true" shader="flat" opacity="0.0"
                          animation__moveup="property: position; from: 0 0.025 -1; to: 0 0.4 -1; dur: 2000; startEvents: moveup; easing: easeInOutQuad"
                          animation__fadein="property: material.opacity; from: 0.0; to: 1.0; startEvents: animtioncomplete__moveup; dur: 1000; startEvents: fadein; easing: easeInOutQuad"
                           animation__fadeout="property: material.opacity; from: 1.0; to: 0.0; dur: 1000; startEvents: animationcomplete__fadein; startEvents: fadeout; easing: easeInOutQuad"
                          
                           arrow-ani>
              </a-image>  
              <a-image id="arrow3" position="0 0.025 -1" scale="0.1 0.1 0.1" src="#arrowhead-image" transparent="true" shader="flat" opacity="0.0"
                          animation__moveup="property: position; from: 0 0.025 -1; to: 0 0.4 -1; dur: 2000; startEvents: moveup; easing: easeInOutQuad "
                          animation__fadein="property: material.opacity; from: 0.0; to: 1.0; startEvents: animtioncomplete__moveup; dur: 1000; startEvents: fadein; easing: easeInOutQuad"
                           animation__fadeout="property: material.opacity; from: 1.0; to: 0.0; dur: 1000; startEvents: animationcomplete__fadein; startEvents: fadeout; easing: easeInOutQuad "
                          
                           arrow-ani>
              </a-image >  
              -->
          </a-entity> 
        <!-- markOT-qmqk8fajid.glb -->
              <a-entity
            id="infoText"
            text="align: center; value: Tor platzieren; color: white; wrapCount: 22; font: ./assets/markOToutline-lp1gchdrai.glb;" 
            position="0 -0.1 -1"
            scale="0.5 0.5 0.5"
            set-initial-info-text>
          </a-entity>
              
           <!-- Logging to screen -->
           <a-log position="1 2.5 -4" visibile="false" debugon></a-log>
            
      </a-camera>


      <!-- main scene holder - used to push door further back on spawn. NOTE: changing Z results in having to move the camera Y up or down -->
      <a-entity id="scene-holder" position="0 -1 -10" portal>
        
             <!-- light -->
              <a-entity
                light="type: directional;
                       intensity: 0;
                       target: #doorEntity;"
                position="1 4.3 2.5">
              </a-entity>
              <a-light type="ambient" intensity="0"></a-light>
        
            <!-- box in front of door for ani in: wScale effected by width of door. yPosition & ySacle (set also in ani) effected by height of door 
            was: 
            scale="20 76 15"
            position="0 38 0"
            animation__showportal="property: scale; from: 20 76 15; to: 20 0 15; dur: 1900; startEvents: showportal; easing: linear "
            -->
              <a-box id="boxInFrontOfDoor"
                scale="20 76 15"
                position="0 38 0"
                animation__showportal="property: scale; from: 20 76 15; to: 20 38 15; dur: 1900; startEvents: showportal; easing: linear "
                hider-material
                show-door-ani-over-logic></a-box>
        
            <!-- Doorway door model (note: order is important as first listed is always drawn on top) 
            Door scale is actually set in 'scaleup-on-tap'. Reason: needs to start at 0, 0, 0 so not seen if user walks forward before spawning. Cannot be hidden otherwise texture is not loaded and causes hitch on show -->
            <a-entity
                id="doorEntity"
                position="0 0 0"
                scale="0 0 0"
                gltf-model="#doorModel"
                visible="true"
                animation__scaleup="property: scale; from: 2.3 0 2.3; to: 2.3 2.3 2.3; dur: 2000; startEvents: scaleup; easing: linear "
                save-orginal-model-material
                show-door-ani-on-tap
                scaleup-on-tap
                >
                    <a-entity
                    id="doorEntityL"
                    position="0 0 0"
                    scale="1 1 1"
                    gltf-model="#door_l"
                    visible="true"
                    animation__open="property: position; to: -1.6 0 0; dur: 1000; startEvents: open; easing: easeInOutQuad "
                    animation__close="property: position; to: 0 0 0; dur: 1000; startEvents: close; easing: easeInOutQuad "
                     >
                      </a-entity>
                    <a-entity
                    id="doorEntityR"
                    position="0 0 0"
                    scale="1 1 1"
                    gltf-model="#door_r"
                    visible="true"
                    animation__open="property: position; to: 1.6 0 0; dur: 1000; startEvents: open; easing: easeInOutQuad "
                    animation__close="property: position; to: 0 0 0; dur: 1000; startEvents: close; easing: easeInOutQuad "
                    >
                      </a-entity>
                    <!-- text sign --> 
                    <!-- standard font: 
                    font: https://cdn.aframe.io/fonts/mozillavr.fnt;" 
                    -->
                    <!-- custom font: 
                    shader: msdf; font:https://raw.githubusercontent.com/etiennepinchon/aframe-fonts/master/fonts/play/Play-Regular.json;"
                    from: https://github.com/etiennepinchon/aframe-fonts -->
                    <a-entity id="sceneLocationTextHolder" scenelocation_textholder_controller>
                        <a-entity
                            id="sceneLocationTextEntity"
                            text="align: center; value: Location; color: white; font: https://cdn.aframe.io/fonts/mozillavr.fnt;" 
                            position="0 8 1.45"
                            scale="12 12 12"
                            scenelocation_text_setter
                            >
                        </a-entity>
                        <!-- text shadow attempt -->
                        <a-entity
                            id="sceneLocationTextShadowEntity"
                            text="align: center; value: Location; color: black; font: https://cdn.aframe.io/fonts/mozillavr.fnt;" 
                            position="0 8 1.4"
                            scale="12.1 12.1 12.1"
                            scenelocation_text_setter
                            >
                        </a-entity>
                    </a-entity>
            </a-entity>
            
      
            <!-- Hider walls -->
            <a-entity id="hider-walls">
              <!-- above portal on front: wScale effected by width of door. yPosition & ySacle (set also in ani) effected by height of door  -->
              <a-box id="abovePortalHiderWall"
                scale="10 100 1"
                position="0 68 0"
                animation__scaleup="property: scale; from: 10 135 1; to: 10 100 1; dur: 2000; startEvents: scaleup; easing: linear "
                hider-material></a-box>
              <!-- front left: wScale effected by width of door-->
              <a-box
                scale="92 100 1"
                position="-50 50 0"
                hider-material></a-box>
              <!-- front right: wScale effected by width of door-->
              <a-box
                scale="92 100 1"
                position="50 50 0"
                hider-material></a-box>
              <!-- back -->
              <a-box
                scale="200 100 1"
                position="0 50 200"
                hider-material></a-box>
              <!-- floor left -->
              <a-box
                scale="200 1 201"
                position="0 100 100"
                hider-material></a-box>
              <!-- floor right -->
              <a-box
                scale="200 1 199"
                position="0 -0.5 100"
                hider-material></a-box>
              <!-- side left -->
              <a-box
                scale="1 100 205"
                position="-100 50 100"
                hider-material></a-box>
              <!-- side right -->
              <a-box
                scale="1 100 205"
                position="100 50 100"
                hider-material></a-box>
            </a-entity>
            
            <!-- return side: xScale effected by width of door. yScale and yHeight effected by door height -->
            <a-entity id="portal-return-opening">
              <a-plane
                scale="7 17 1"
                rotation="180 0 0"
                position="0 8.5 0.5"
                hider-material></a-plane>
            </a-entity>
      
            <a-entity id="portal-contents"  >
              
              <!-- Balcony  -->
                <a-entity id="balcony"
                position="0 0 0"
                gltf-model="#balconyModel"
                scale="0 0 0"
                visible="true"
                animation__scaleup="property: scale; from: 2.3 0 2.3; to: 2.3 2.3 2.3; dur: 2000; startEvents: scaleup; easing: easeOutQuad "
                save-orginal-model-material
                show-door-ani-on-tap
                scaleup-on-tap></a-entity>
                
             <!-- video sphere 360 video - do not change default rotation required for template lookup -->
           <a-videosphere id="videosphere" rotation="0 90 0" src="#video1"  videoeventhandler hide-after-load show-on-tap>
           </a-videosphere>    
      
            <!-- sky background for 360 photo - do not change default rotation required for template lookup -->
            <a-sky id="photosphere" rotation="0 90 0" src="#photo" photo-or-video hide-after-load show-on-tap></a-sky>
            
            <!-- ground outside if separate should go here --> 
              
            </a-entity>
        
            <!-- ground inside portal --> 
       
            <a-entity id="portal-world">
             
            </a-entity>
            
   
            
            <!-- Audio tracks -->
            
            <!-- narrator audio track -->
            <a-entity id="soundcue" sound="src: #audio; autoplay: false;"></a-entity>
            <a-entity id="doorSpawnSoundCue" sound="src: #doorSpawningAudio; autoplay: false;"></a-entity>
            <a-entity id="doorOpenSoundCue" sound="src: #doorOpeningAudio; autoplay: false;"></a-entity>
            
     </a-entity>
    
    <!-- visible ground reference for debugging
     <a-entity
        id="ground"
        class="cantap"
        geometry="primitive: box"
        material="color: #000000; transparent: true; opacity: 0.4"
        scale="1000 2 1000"
        position="0 -1 0"
        transparent=true
        >
      </a-entity>
     -->
    </a-scene>
    
   

  
  
  </html>
 `;